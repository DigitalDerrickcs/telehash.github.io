<html><head><title>Telehash Secure Mesh Protocol</title><link href='tools/pdf.css' type='text/css'></link><link href='tools/code-style/default.css' type='text/css'></link></head><body data-type='book'><section data-type='titlepage'><img src='v3/spec/logo/mesh-logo.svg' /><div class='spec-title'>telehash</div></section><nav data-type='toc'><h1>Table of Contents</h1><ol><li><a href='#intro'>Introduction</a></li><li><a href='#glossary'>Glossary</a></li><li><a href='#base32'>Base 32</a></li><li><a href='#hashname'>Hashnames</a></li><li><a href='#lob'>Packet Format</a></li><li><a href='#link'>Links</a></li><li><a href='#routing'>Routing</a></li><li><a href='#mesh'>Mesh Network</a></li><li><a href='#uri'>URI Handling</a></li><li><a href='#e3x_intro'>E3X - End-to-End Encrypted eXchange</a><ol><li><a href='#e3x_exchange'>Exchange - Endpoint Encryption State</a></li><li><a href='#e3x_messages'>Messages - Asynchronous Content Transport</a></li><li><a href='#e3x_order'>Endpoint Order</a></li><li><a href='#e3x_handshake'>Handshake - Mutual Exchange Creation</a></li><li><a href='#e3x_channels'>Channels - Streaming Content Transport</a></li><li><a href='#e3x_reliable'>Reliable Channels</a></li><li><a href='#e3x_compression'>Channel Payload Compression</a></li><li><a href='#e3x_cloaking'>Cloaking - Network Obfuscation</a></li><li><a href='#e3x_cs_'>Cipher Sets</a></li></ol></li><li><a href='#chunking'>Packet Chunking</a></li><li><a href='#transports_'>Transport Bindings</a><ol><li><a href='#transports_udp'>UDP Transport</a></li><li><a href='#transports_tcp'>TCP Transport</a></li><li><a href='#transports_tls'>TLS/SSL Transport</a></li></ol></li><li><a href='#channels_'>Channels</a><ol><li><a href='#channels_path'><code>path</code> - Network Path Information</a></li><li><a href='#channels_peer'><code>peer</code> - Routing Request</a></li><li><a href='#channels_connect'><code>connect</code> - Peer Connection Request</a></li><li><a href='#channels_stream'><code>stream</code> - Reliable Data Streams</a></li><li><a href='#channels_sock'><code>sock</code> - Tunneled TCP/UDP Sockets</a></li><li><a href='#channels_thtp'><code>thtp</code> - HTTP Mapping</a></li></ol></li></ol></nav><a id='intro' name='intro'></a><a id='chapter-1-0' name='chapter-1-0'></a><section data-type='chapter'><p>teleÂ·hash</p>
<blockquote>
<p>n. <em>Internet</em>, from <strong>tele</strong>graph and <strong>hash</strong>table</p>
</blockquote>
<h1 id="intro">Introduction</h1>
<p>Telehash is a 100% open, secure mesh networking technology with these design principles:</p>
<ul>
<li>full end-to-end encryption, all the time</li>
<li>strict privacy: no content, identity, or metadata is ever revealed to third parties</li>
<li>maximum app/device compatibility: suitable for embedded, mobile, and web usage</li>
<li>making privacy the <strong>easy</strong> choice for developers</li>
<li>flexible transport protocols, for compatibility with existing layers</li>
<li>native implementations for the widest possible variety of languages/platforms</li>
</ul>
<p>The telehash team includes collaborators from around the world, many of whom were the principal architects of <a href="http://en.wikipedia.org/wiki/XMPP">XMPP</a>. It is intended as a next-generation protocol advancing the original goals of Jabber.</p>
<p><img src="v3/BasicNetwork.png" alt="Basic Network"/></p>
<p>The basic architecture contains application or device instances that each maintain a logical <a class="xref" href="#mesh">mesh</a> which is just a collection of secure <a class="xref" href="#link">links</a> to other instances.  Every endpoint has its own view of the mesh, a link between two instances is private only to them and not shared across the mesh.</p>
<p>The current v3 protocol has these high-level properties:</p>
<ul>
<li>each endpoint has verifiable unique fingerprint (a <a class="xref" href="#hashname">hashname</a>), a secure universal MAC address</li>
<li>provides native tunneling of TCP/UDP sockets, HTTP, object streams, and more</li>
<li>facilitates asynchronous and synchronous messaging and eventing</li>
<li>supports an automatic peer discovery mode when available on local transports</li>
<li>specifies a <a class="xref" href="#uri">URI</a> format for initiating new links out-of-band</li>
<li>supports bridging and routing privately by default and optionally via a <a href="https://github.com/telehash/blockname">public DHT (draft)</a></li>
<li>integrates native support for <a href="https://datatracker.ietf.org/wg/jose/charter/">JSON Object Signing and Encryption (JOSE)</a> and <a href="http://openid.net/connect/">OpenID Connect</a></li>
</ul>
<p><img src="v3/THStack.png" alt="Telehash Stack"/></p>
<p>The protocol stack is separated into two main areas, a lower level <a class="xref" href="#e3x_intro">end-to-end encrypted exchange (E3X)</a> that handles all of the security primitives and encrypted <a class="xref" href="#e3x_messages">messages</a>, and higher application-level definitions for managing a <a class="xref" href="#mesh">mesh</a> of <a class="xref" href="#link">links</a> that support standard <a class="xref" href="#channels_">channels</a>, <a class="xref" href="#transports_">transports</a>, and <a class="xref" href="#uri">URIs</a>.</p>
<h2>Design Philosophy</h2>
<p>The primary idea that drove the creation and development of telehash
is the belief that any application instance should be able to easily and
securely talk to any other application instance or device, whether they are two
instances of the same application, or completely different
applications. They should be able to do so directly, and in any
environment, from servers to mobile devices down to embedded systems
and sensors.</p>
<p>By enabling this freedom for developers as a foundation for their
applications, telehash enables the same freedom for the people using
them - that the user can connect, share, and communicate more easily
and with control of their privacy.</p>
<p>The challenges and complexity today in connecting applications via
existing technologies such as APIs, OAuth, and REST are only increasing,
often forcing fundamentally insecure, centralized, and closed/gated
communication platforms.  By adopting telehash, an
application immediately has a powerful set of open tools for 
its own needs, but can also easily enable connectivity to and from
applications created by others. These tools include the ability
to have friends, sharing, feeds, tagging, search, notifications,
discovery, transactions, and other social patterns.</p>
<p>Telehash has a fundamental requirement to remain simple and
lightweight in order to support applications running on networked
devices and sensors. The design goals also include not forcing any
specific architectural pattern such as client-server,
centralized/federated/distributed, polling/push, REST, streaming,
publish-subscribe, or message passing... any can be used, as telehash
simply facilitates secure reliable connectivity between any two or more
applications in any networking environment.</p>
<p><a name="usage" /></p>
<h2>Usage</h2>
<p>The word <em>telehash</em> should be pronounced as the root terms would normally be pronounced in the speaker&#39;s native dialect.</p>
<p>It is usually written in all lower-case in the sense of a modern version of the word &quot;telephone&quot;, both as a generic private communication system that is federated and compatible, and the act of two application instances communicating privately and directly.</p>
<p><a name="logo" /></p>
<h2>Logo</h2>
<p><img src="logo/mesh-logo-128.png" alt="logo-128"/></p>
<p>The telehash <a href="https://github.com/telehash/telehash.org/tree/master/v3/logo">logo</a> was designed and contributed by <a href="https://github.com/jingman">Jake Ingman</a> and is freely available for apps to use in representing support and current mesh connectivity status.</p>
<p>The official color is <a href="http://www.color-hex.com/color/2a7e60">#2a7e60</a>.</p>
<h2>Change Log</h2>
<h3>v1</h3>
<p>The name and first version of the protocol was established in <a href="https://github.com/quartzjer/Telehash">2009</a> by <a href="http://en.wikipedia.org/wiki/Jeremie_Miller">Jeremie Miller</a> and was primarily a DHT-P2P <a href="http://quartzjer.tumblr.com/post/71784515314/telehash-history">research project</a>.</p>
<h3>v2</h3>
<p>In 2013 it was significantly updated with a privacy focus as <a href="https://github.com/telehash/telehash.org/tree/master/v2">v2</a>.</p>
<h3>v3</h3>
<p>In 2014 the protocol was refactored and simplified: the wire encryption format was codified as <a class="xref" href="#e3x_intro">E3X</a> and the DHT functionality was moved into a separate project called <a href="https://github.com/telehash/blockname">blockname</a>.</p>
<ul>
<li><a class="xref" href="#spec_v3.0.0-rc1.pdf">v3.0.0-rc1</a> released on 2015-04-04</li>
</ul>
</section><a id='glossary' name='glossary'></a><a id='chapter-2-0' name='chapter-2-0'></a><section data-type='chapter'><h1 id="glossary">Glossary</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a class="xref" href="#channels_">channel</a></td>
<td>a virtual stream that allows two <em>endpoints</em> to exchange data reliably or unreliably</td>
</tr>
<tr>
<td><a class="xref" href="#chunking">chunking</a></td>
<td>a packet is <em>chunked</em> into smaller pieces for low-MTU or streaming transports</td>
</tr>
<tr>
<td><a class="xref" href="#e3x_cloaking">cloaking</a></td>
<td>method used to hide telehash traffic on the wire by randomizing all data sent</td>
</tr>
<tr>
<td><a class="xref" href="#e3x_cs_">CS</a></td>
<td><em>Cipher Set</em>, a collection of crypto algorithms with a given <em>CSID</em></td>
</tr>
<tr>
<td><a class="xref" href="#e3x_cs_">CSID</a></td>
<td><em>Cipher Set ID</em>, predefined hex number identifying a <em>CS</em></td>
</tr>
<tr>
<td><a class="xref" href="#e3x_cs_">CSK</a></td>
<td><em>Cipher Set Key</em>, the public key bytes for a given <em>CSID</em></td>
</tr>
<tr>
<td><a class="xref" href="#link">endpoint</a></td>
<td>a participant in the telehash network identified by a single <em>hashname</em></td>
</tr>
<tr>
<td><a class="xref" href="#e3x_intro">E3X</a></td>
<td><em>End-to-End Encrypted eXchange</em>, a flexible encrypted exchange wire protocol</td>
</tr>
<tr>
<td><a class="xref" href="#e3x_exchange">exchange</a></td>
<td>the current encrypted session state between two endpoints</td>
</tr>
<tr>
<td><a class="xref" href="#e3x_handshake">handshake</a></td>
<td><em>message</em> type used to establish an encrypted <em>session</em> for <em>channels</em></td>
</tr>
<tr>
<td><a class="xref" href="#hashname">hashname</a></td>
<td>an <em>endpoint</em> identifier, calculated from all of its <em>CSKs</em></td>
</tr>
<tr>
<td><a class="xref" href="#lob">LOB</a></td>
<td><em>Length-Object-Binary</em>, an encoding format that allows combining JSON and binary data</td>
</tr>
<tr>
<td><a class="xref" href="#link">link</a></td>
<td>a connection between two <em>endpoints</em> either directly or via a <em>router</em></td>
</tr>
<tr>
<td><a class="xref" href="#mesh">mesh</a></td>
<td>a number of <em>links</em> with active encrypted <em>sessions</em> over any <em>transport</em>; participants in the mesh are called <em>endpoints</em></td>
</tr>
<tr>
<td><a class="xref" href="#e3x_messages">message</a></td>
<td>an asynchronous encrypted packet between two <em>endpoints</em></td>
</tr>
<tr>
<td><a class="xref" href="#lob">packet</a></td>
<td>an encapsulation format for JSON and binary data using <em>length object binary (LOB)</em> encoding</td>
</tr>
<tr>
<td><a class="xref" href="#routing">router</a></td>
<td>an <em>endpoint</em> that will facilitate link setup between two other endpoints</td>
</tr>
<tr>
<td><a class="xref" href="#transports_">transport</a></td>
<td>underlying network responsible for <em>packet</em> transfer</td>
</tr>
<tr>
<td><a class="xref" href="#uri">URI</a></td>
<td><em>Uniform Rescource Identifier</em>, to enable endpoints to share enough information (<em>hashname</em>, <em>transport</em>) for out-of-band connection setup and references</td>
</tr>
</tbody>
</table>
</section><a id='base32' name='base32'></a><a id='chapter-3-0' name='chapter-3-0'></a><section data-type='chapter'><h1 id="base32">Base 32</h1>
<p>All base 32 encoding used in this document is defined by <a href="http://tools.ietf.org/html/rfc4648">RFC 4648</a> with <a href="http://tools.ietf.org/html/rfc4648#section-3.2">no padding</a> and using only the lower case alphabet of <code>abcdefghijklmnopqrstuvwxyz234567</code>.</p>
<p>It is used frequently to encode binary 32 byte <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-256</a> digests safely for use in JSON and URIs, resulting in a 52 character string, for example: <code>kw3akwcypoedvfdquuppofpujbu7rplhj3vjvmvbkvf7z3do7kkq</code>.  It is sometimes also used to encode public key material, small JSON objects, and in implementations to print binary values for debugging.</p>
<p>Base 32 encoding was chosen to maximize compatibilty and consistency, such that it is usable in any part of a URI and as DNS labels, and is case insensitive and alphanumeric only. It&#39;s only used for small fixed values where interchanging the data safely is more important than efficency, and is never used to encode dynamic application data over a transport.</p>
</section><a id='hashname' name='hashname'></a><a id='chapter-4-0' name='chapter-4-0'></a><section data-type='chapter'><h1 id="hashname">Hashnames</h1>
<p>A <em>hashname</em> is a unique fingerprint to represent the union of one or more public keys of different formats (<a class="xref" href="#e3x_cs_">Cipher Sets</a>), providing consistent verifiable endpoint addresses when utilizing multiple different public-key algorithms. This enables a compatibility layer for improving the algorithms used so that any application can increase security in newer versions while still being able to represent itself securely to older ones.</p>
<p>A <em>hashname</em> can be viewed as a portable, secure, virtual equivalent of a <a href="http://en.wikipedia.org/wiki/MAC_address">MAC address</a>, since it is a universally unique identifier for a network endpoint that is also self-generated and cryptographically verifiable.</p>
<p>The value is always a <a class="xref" href="#base32">base 32</a> encoded string that is 52 characters long.  When decoded it is always a 32 byte binary value, which corresponds to the result of a <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-256</a> hash digest.  An example <em>hashname</em> is <code>kw3akwcypoedvfdquuppofpujbu7rplhj3vjvmvbkvf7z3do7kkq</code>.</p>
<h2>Hashname Generation</h2>
<p>A hashname is calculated by combining one or more Cipher Set Keys (<a class="xref" href="#e3x_cs_">CSK</a>) through multiple rounds of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-256</a> hashing.</p>
<p>The generation has three distinct steps, all of them operating on binary/byte inputs and outputs:</p>
<ol>
<li>Every <code>CSK</code> is identified by a single unique <code>CSID</code> and sorted by it from low to high (e.g. <code>CS1a</code> is lower then <code>CS3a</code>)</li>
<li>Each <code>CSK</code> is hashed into <em>intermediate</em> digest values</li>
<li>Roll-up hashing of the <code>CSIDs</code> and <em>intermediate</em> values generates the final 32-byte digest</li>
</ol>
<p>Any <em>hashname</em> generation software does not need to know or understand the Cipher Sets or support the algorithms defined there, it only has to do the consistent hashing of any given set of <code>CSID</code> and <code>CSK</code> pair inputs.</p>
<p>The <em>intermediate</em> digest values may be used and exchanged directly instead of the original <code>CSK</code> to minimize the amount of data required to calculate and verify a <em>hashname</em> with multiple keys.</p>
<h3>Final Rollup</h3>
<p>To calculate the <em>hashname</em> the <em>intermediate</em> digests are sequentially hashed in ascending order by their <code>CSID</code>. Each one contributes two values: the single byte <code>CSID</code> value and the 32 byte <em>intermediate</em> digest value. The calculated hash is rolled up, wherein each resulting 32 byte binary output is concatenated with the next binary value as the input. An example calculation would look like (in pseudo-code):</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">hash = sha256(0x1a)</code></div><div class="line number2 index1 alt1"><code class="plain">hash = sha256(hash + 0x21b6...f350)</code></div><div class="line number3 index2 alt2"><code class="plain">hash = sha256(hash + 0x3a)</code></div><div class="line number4 index3 alt1"><code class="plain">hash = sha256(hash + 0x97d8...7101)</code></div><div class="line number5 index4 alt2"><code class="plain">final = hash</code></div></div></td></tr></tbody></table></div></section><a id='lob' name='lob'></a><a id='chapter-5-0' name='chapter-5-0'></a><section data-type='chapter'><h1 id="lob">Packet Format</h1>
<p>This is a simple encoding scheme to combine any JSON object with any binary data (both are optional) into one byte array, often referred to as a single <code>packet</code>.  This encoding does not include any total packet size or checksums, and expects the context where it&#39;s used to provide those when necessary (see <a class="xref" href="#chunking">chunking</a>).</p>
<h2>Definition</h2>
<p>The wire-format byte array (a packet) is created by combining three distinct parts: the <code>LENGTH</code>, an optional <code>HEAD</code>, and an optional <code>BODY</code>.</p>
<p>The <code>LENGTH</code> is always two bytes which are a network-order (big-endian) short unsigned integer that represents the number of bytes for the <code>HEAD</code>.  When the <code>HEAD</code> is greater than 6 bytes the data are always parsed and represented as a UTF-8 JSON object.  Any bytes remaining after the <code>HEAD</code> are the <code>BODY</code> and always handled as binary.</p>
<p>The format is thus:</p>
<pre><code>&lt;LENGTH&gt;[HEAD][BODY]
</code></pre><p>A simplified example of how to decode a packet, written in Node.js:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">dgram.createSocket(</code><code class="string">"udp4"</code><code class="plain">, </code><code class="keyword">function</code><code class="plain">(msg){</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword">var</code> <code class="plain">head_len = msg.readUInt16BE(0);</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword">var</code> <code class="plain">head = msg.slice(2, head_len + 2);</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword">var</code> <code class="plain">body_len = msg.length - (head_len + 2);</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword">var</code> <code class="plain">body = msg.slice(head_len + 2, body_len);</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword">if</code> <code class="plain">(head_len >= 7) {</code></div><div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">var</code> <code class="plain">json = JSON.parse(head);</code></div><div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">}</code></div><div class="line number9 index8 alt2"><code class="plain">});</code></div></div></td></tr></tbody></table></div><p>It is only a parsing error when the <code>LENGTH</code> is greater than the size of the packet.  When successful, parsers must always return five values:</p>
<ul>
<li><code>HEAD LENGTH</code> - 0 to packet length - 2</li>
<li><code>HEAD</code> - undefined/null or binary</li>
<li><code>JSON</code> - undefined/null or decoded object</li>
<li><code>BODY LENGTH</code> - 0 to packet length - (2 + HEAD LENGTH)</li>
<li><code>BODY</code> - undefined/null or binary</li>
</ul>
<h2>LENGTH / HEAD</h2>
<p>A <code>LENGTH</code> of 0 means there is no <code>HEAD</code> included and the packet is all binary (only <code>BODY</code>).</p>
<p>A <code>LENGTH</code> of 1-6 means the <code>HEAD</code> is only binary (no JSON).</p>
<p>A <code>LENGTH</code> of 7+ means the <code>HEAD</code> may be a UTF-8 encoded JSON object (not any bare string/bool/number/array value) within the guidelines of <a href="https://datatracker.ietf.org/doc/draft-ietf-json-i-json/?include_text=1">I-JSON</a> beginning with a <code>{</code> and ending with a <code>}</code> character.</p>
<p>If the JSON object parsing fails, the parser must include an error but still return the decoded <code>HEAD</code>/<code>BODY</code> byte structures and lengths.</p>
<h2>BODY</h2>
<p>The optional <code>BODY</code> is always a raw binary of the remainder bytes between the end of the <code>HEAD</code> and the total length of the packet. </p>
<p>Often packets are attached inside other packets as the <code>BODY</code>, enabling simple packet wrapping/relaying usage patterns (see below).</p>
<p><a name="jose" /></p>
<h2>JSON Web Encryption / Signing (JWE/JWS)</h2>
<p>LOB encoding can be used as an optimized serialization of the <a href="https://datatracker.ietf.org/wg/jose/charter/">JOSE</a> based <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-40">JWE</a>  and <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41">JWS</a> standards.</p>
<p>The LOB encoding is simply a consistent binary translation of the JWS/JWE compact serialization; there are no semantic changes to the contents in either direction.</p>
<p><a name="jws" /></p>
<h3>JWS</h3>
<p>Any <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41">JWS</a> can be mapped to two LOB packets (one attached to another):</p>
<ul>
<li>HEAD: {JWS Protected Header (JWT Header)}</li>
<li>BODY: attached LOB<ul>
<li>HEAD: {JWS Payload (JWT Claims)}</li>
<li>BODY: JWS Signature (binary)</li>
</ul>
</li>
</ul>
<p>The attached HEAD is treated as a binary octet string when translating. Even though it is frequently JSON it must be preserved as the original bytes for signature validation and non-JSON use cases.</p>
<p><a name="jwe" /></p>
<h3>JWE</h3>
<p>Any <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-40">JWE</a> can be mapped to three LOB packets (as attached descendents):</p>
<ul>
<li>HEAD: {JWE Protected Header}</li>
<li>BODY: attached LOB<ul>
<li>HEAD: {JWE JSON (Encrypted Key, IV, Tag, AAD)}</li>
<li>BODY: attached LOB<ul>
<li>HEAD: {optional unprotected header}</li>
<li>BODY: JWE Ciphertext (binary)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Example:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code><code class="string">"alg"</code><code class="plain">:</code><code class="string">"RSA-OAEP"</code><code class="plain">,</code><code class="string">"enc"</code><code class="plain">:</code><code class="string">"A256GCM"</code><code class="plain">}</code></div><div class="line number2 index1 alt1"><code class="plain">BODY: {</code><code class="string">"aad"</code><code class="plain">:</code><code class="string">""</code><code class="plain">,</code><code class="string">"iv"</code><code class="plain">:</code><code class="string">""</code><code class="plain">,</code><code class="string">"tag"</code><code class="plain">:</code><code class="string">""</code><code class="plain">,</code><code class="string">"encrypted_key"</code><code class="plain">:</code><code class="string">""</code><code class="plain">}</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">BODY: (no header)</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">BODY: ciphertext</code></div></div></td></tr></tbody></table></div></section><a id='link' name='link'></a><a id='chapter-6-0' name='chapter-6-0'></a><section data-type='chapter'><h1 id="link">Links</h1>
<p>A <em>link</em> is the core connectivity mechanism between two endpoints. An endpoint managing one or more links is referred to as a <em>mesh</em>.</p>
<h2>Terminology</h2>
<ul>
<li><strong>Link CSID</strong> - the highest matching <code>CSID</code> between two endpoints</li>
<li><strong>Link Keys</strong> - the one or more <code>CSKs</code> of the other endpoint, at a minimum must include the <code>CSID</code> one</li>
<li><strong>Link Paths</strong> - all known or potential path information for connecting a link</li>
<li><strong>Link Handshake</strong> - a handshake that contains one <code>CSK</code> and the intermediate hashes for any others to validate the <em>hashname</em> and encrypt a response</li>
</ul>
<h2>Link State</h2>
<p>Links can be in three states:</p>
<ul>
<li><strong>Unresolved</strong> - at least the hashname is known, but either the Link Keys or Link Paths are incomplete</li>
<li><strong>Down</strong> - keys have been validated and at least one path is available (possibly through <a class="xref" href="#routing"><em>router</em></a>), but the link is not connected</li>
<li><strong>Up</strong> - link has sent and received a handshake and is active</li>
</ul>
<p><a name="json" /></p>
<h2>JSON</h2>
<p>Many apps use JSON as an easy storage/exchange format for defining and sharing link data.  The only required standard for this is that each link is an object with two fields, a <code>keys</code> object and a <code>paths</code> array.  Apps may extend and customize the JSON as needed but should attempt to preserve those two fields to simplify what other tools and libraries can automatically detect and generate.</p>
<p>It&#39;s common to have a <code>hashname</code> field as well for convenience or as the verified value if only one <code>CSK</code> is stored.</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"keys"</code><code class="plain">: {</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"1a"</code><code class="plain">: </code><code class="string">"aiw4cwmhicwp4lfbsecbdwyr6ymx6xqsli"</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">},</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"paths"</code><code class="plain">: [</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"192.168.0.55"</code><code class="plain">,</code></div><div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 61407,</code></div><div class="line number9 index8 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"udp4"</code></div><div class="line number10 index9 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">},</code></div><div class="line number11 index10 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number12 index11 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"peer"</code><code class="plain">: </code><code class="string">"e5mw...ylka"</code><code class="plain">,</code></div><div class="line number13 index12 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"peer"</code></div><div class="line number14 index13 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></div><div class="line number15 index14 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">],</code></div><div class="line number16 index15 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"hashname"</code><code class="plain">: </code><code class="string">"frnf...bjdq"</code></div><div class="line number17 index16 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p>The <code>keys</code> object is always a dictionary of at least the single <code>CSID</code> for the link, with all string values being a <a class="xref" href="#base32">base 32</a> encoding of the binary <code>CSK</code> for that given <code>CSID</code>.</p>
<p>The <code>paths</code> array is always the list of current or recent <a class="xref" href="#channels_path">path values</a> and should contain only external paths when shared or a mix of both internal and external when used locally.</p>
<p><a name="jwk" /></p>
<h2>JSON Web Key (JWK)</h2>
<p>The Link Keys can also be represented in a standard <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-key-41">JWK</a> using a <code>kty</code> of <code>hashname</code>:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"kty"</code><code class="plain">: </code><code class="string">"hashname"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"kid"</code><code class="plain">: </code><code class="string">"27yw...lwxa"</code><code class="plain">,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"use"</code><code class="plain">: </code><code class="string">"link"</code><code class="plain">,</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"cs1a"</code><code class="plain">: </code><code class="string">"an7l...mzlm"</code><code class="plain">,</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"cs3a"</code><code class="plain">: </code><code class="string">"eg3fx...6nia"</code></div><div class="line number7 index6 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p>The <code>kid</code> must always be the matching/correct hashname for the included keys.  The <code>use</code> value must always be <code>link</code> as it can only be used to create links.</p>
<p>The JWK may also contain a <code>&quot;paths&quot;:[...]</code> array if required. Often the JWK is only used as <a class="xref" href="#discovery">authority validation</a> and does not require bundling of the current link connectivity information.</p>
<h2>Resolution</h2>
<p>Links can be resolved from any string:</p>
<ol>
<li><a class="xref" href="#json">JSON</a></li>
<li><a class="xref" href="#uri">Direct URI</a> (no fragment)</li>
<li><a class="xref" href="#peer">Peer URI</a> (<a class="xref" href="#routing">router</a> assisted, with fragment)</li>
<li>hashname - <a class="xref" href="#channels_peer">peer request</a> to default <a class="xref" href="#routing">router(s)</a></li>
</ol>
<p>Once resolved, all paths should be preserved for future use.  If resolved via a <a class="xref" href="#routing">router</a> a <code>peer</code> type path should be preserved referencing that <a class="xref" href="#routing">router</a>.</p>
<p><a name="handshake" /></p>
<h2>Handshake</h2>
<p>In order to establish a link both endpoints must first send and receive an encrypted <a class="xref" href="#e3x_handshake"><em>handshake</em></a>. The minimum required handshake packet is of <code>&quot;type&quot;:&quot;link&quot;</code> and the <code>BODY</code> is another encoded packet that contains the sender&#39;s hashname details.</p>
<p>The attached packet must include the correct <code>CSK</code> of the sender as the <code>BODY</code> and the JSON contains the intermediate hash values of any other <code>CSIDs</code> used to generate the hashname.</p>
<p>Example:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">:</code><code class="string">"link"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"at"</code><code class="plain">:123456789,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"csid"</code><code class="plain">:</code><code class="string">"2a"</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div><div class="line number6 index5 alt1"><code class="plain">BODY:</code></div><div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"3a"</code><code class="plain">: </code><code class="string">"eg3f...6nia"</code><code class="plain">,</code></div><div class="line number9 index8 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"1a"</code><code class="plain">: </code><code class="string">"ckcz...em6q"</code></div><div class="line number10 index9 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">}</code></div><div class="line number11 index10 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">BODY: [2a's CSK binary bytes]</code></div></div></td></tr></tbody></table></div><p>The <code>&quot;csid&quot;:&quot;2a&quot;</code> is optional when sent as an encrypted message, but required when sent in a <a class="xref" href="#channels_peer">peer</a> channel.</p>
<p><a name="jwt" /></p>
<h2>Identity (JWT)</h2>
<p>The endpoints connected over a link are always uniquely identified by their hashnames. A hashname serves as stable, universally unique, verifiable address, but is not intended to be used as a higher-level identity for an end user or other entity beyond the single instance/device.  Once a hashname is generated in a new context, it should be registered and associated with other portable identities by the application.</p>
<p><a href="http://openid.net/connect/">OpenID Connect</a> or any service that is able to generate a <a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JSON Web Token</a> can be used for primary user/entity identification, enabling strongly encrypted communication to be easily coupled with standard identity management tools.</p>
<p>Just as a JWT is sent as a Bearer token over HTTP, it can be automatically included as part of the <a class="xref" href="#e3x_handshake">handshake process</a> between endpoints with a <code>&quot;type&quot;:&quot;jwt&quot;</code>.  This enables applications to require additional context before deciding to establish a link or apply restrictions on what can be performed over the link once it is established.</p>
<h3>Audience</h3>
<p>When an <a href="http://openid.net/specs/openid-connect-basic-1_0.html#IDToken">ID Token</a> is generated specifically for one or more known hashnames, the hashname must be included in the <code>aud</code> as one of the items in the array value.</p>
<h3>Scope</h3>
<p>When a client is requesting to establish a new link to an identity, it must include the scope value <code>link</code> during authorization.</p>
<h3>Claims</h3>
<p>An identity may advertise its connectivity by including a <code>link</code> member in the <a href="http://openid.net/specs/openid-connect-basic-1_0.html#StandardClaims">Standard Claims</a>.  The value must be a valid <a class="xref" href="#uri">URI</a> that can be resolved to establish a link, and any resulting linked hashname must be included in the token&#39;s <code>aud</code> audience values.</p>
</section><a id='routing' name='routing'></a><a id='chapter-7-0' name='chapter-7-0'></a><section data-type='chapter'><h1 id="routing">Routing</h1>
<p>A <code>router</code> in telehash is simply any endpoint that is willing to forward packets between two other endpoints, at least one of which it must already have a <a class="xref" href="#link">link</a> for.  These packets are encrypted such that the routing endpoint cannot decode the contents, but all usage of routing requires a trusted relationship since the routers are at least aware of which two endpoints are connecting to each other.</p>
<p>When a <code>router</code> is forwarding the initial handshakes for endpoints first connecting, typically those endpoints will be able to negotiate and establish direct connections immediately and not rely on the router to forward future packets for that session.  To support situations in which there is no working direct network path between the two endpoints, the router should continue forwarding packets but may rate-limit them to reduce the impact on its own network.</p>
<p>Any <code>router</code> role is an explicit choice by the application, either based on an administrative decision (specific default routers) or a trust relationship (offering to route for friends).  These may be through configuration values or automatically discovered by advertising support through a <code>peer</code> in the <a class="xref" href="#channels_path">path</a> channel.</p>
<p>All routing is performed by using a <a class="xref" href="#channels_peer">peer</a> channel to the router, and a <a class="xref" href="#channels_connect">connect</a> channel from the router to the requested endpoint.  A <code>router</code> never responds to or reveals any known state about the target endpoint to the requesting endpoint.</p>
<p>The use of <a class="xref" href="#uri">URIs</a> may be supported by routers to facilitate easier methods of connecting to new/third-party endpoints.</p>
<p>A <a class="xref" href="#mesh">mesh</a> may have one or more default routers which are sent a peer request for every new link connection attempt.  Each link may have one or more routers that are signalled from the link itself through a peer path or other application-level relationships, and these routers are used for all future connection attempts for that link.</p>
</section><a id='mesh' name='mesh'></a><a id='chapter-8-0' name='chapter-8-0'></a><section data-type='chapter'><h1 id="mesh">Mesh Network</h1>
<p>A mesh network consists of one or more <a class="xref" href="#link">links</a>, which are active <a class="xref" href="#e3x_">encrypted sessions</a> between two endpoints over any <a class="xref" href="#transports_">transport</a> established by exchanging <a class="xref" href="#e3x_handshake">handshakes</a>.  </p>
<p>Each link is identified with a unique <a class="xref" href="#hashname">hashname</a>.  A mesh is private to each endpoint, which has complete control over what links it accepts (there is no automatic sharing of any link state to any other endpoint).</p>
<p>Once handshakes are verified and a link is up, <a class="xref" href="#channels_">channels</a> are used to send data over the link between endpoints.</p>
<p>Any link may be set as a <a class="xref" href="#routing">router</a> when it is known that it will provide relaying/bridging to other links.  Any endpoint may advertise its <a class="xref" href="#routing">router</a> as a path to other endpoints that may not have the same router.  An endpoint may also use a base <a class="xref" href="#uri">URI</a> from a <a class="xref" href="#routing">router</a> as an out-of-band mechanism to establish new links.</p>
<p><a name="discovery" /></p>
<h2>Discovery</h2>
<p>By default a local endpoint will never respond to any request unless it comes from a link it already knows and trusts.  Implementations should support a <code>discover</code> mode that can be enabled to temporarily change this behavior and broadcast the endpoint&#39;s hashname and keys to any local <a class="xref" href="#transports_">network transport</a> that supports discovery.</p>
<p>This mode should be used sparingly so that local networks cannot record what endpoints are available. Typically this is enabled only based on a user behavior (&quot;add a friend&quot; or &quot;pair device&quot;, etc) and only for a short period of time.  Permanent, local, well-known services/servers that support dynamic association may have it always enabled.</p>
<p>All transports that support discovery should always be listening for incoming <code>discover</code> announcements regardless of the discovery state and pass those to the application to evaluate.  Discovery does not need to be enabled to receive announcements and see other endpoints, only to announce the local endpoint.</p>
</section><a id='uri' name='uri'></a><a id='chapter-9-0' name='chapter-9-0'></a><section data-type='chapter'><h1 id="uri">URI Handling</h1>
<p>URIs are a convenient method for endpoints to convey connectivity information in any out-of-band medium. This defines a process for handling any URI to automatically detect associated keys and paths, as well as standard practices for embedding that information in any generated or existing URIs.</p>
<p>Once a URI is successfully resolved and a link is established to an endpoint the key and path information should be stored and used in place of the URI, a successful resolution only needs to be performed once.</p>
<h2>Generation</h2>
<p>New URIs that are generated by applications for the sole purpose of establishing a new link take the minimal form of: <code>link://host:port/?csid=base32</code></p>
<ul>
<li><code>link://</code> - defaults to <code>link</code> but may be any app-specific name for registering custom URL handlers</li>
<li><code>host:port</code> - the <code>host</code> is often an IP address, and the port defaults to <code>42424</code> if not included</li>
<li><code>cs??=base32</code> - (optional) a key/value pair for each of the sender&#39;s public keys in <a class="xref" href="#base32">base 32</a></li>
</ul>
<p>A generated URI will often include additional pathname or query string values as needed by the application.</p>
<p>Examples:</p>
<pre><code>chat://127.0.0.1:55772/?cs1a=aof7...supy
</code></pre><p><a name="peer" /></p>
<h3>Router / Peer URI</h3>
<p>A common deployment architecture includes a designated stable router that facilitates the connection process with peers.  The router can generate an authorative base URI for peers to re-use and advertises it to them in a <a class="xref" href="#channels_path">path</a> request.  This allows a peer to be reachable via a URI but still remain private and not share any of its identity information (hashname, keys, or paths).</p>
<p>The router may include its own keys in the query string but may not attach a <code>#fragment</code> so that a peer can use the fragment part to include additional data before distributing the URI.  The router must always include a value in the base URI to validate the request and internally map it to the peer it was generated for, it should never embed or expose the hashname or other specific details about the peer in the base URI.</p>
<p>The peer endpoint must generate a fragment value that it can use to validate incoming requests and the recipient can use to verify the peer&#39;s hashname.  This fragment has two parts separated by a <code>.</code>, both are base32 encoded byte strings.  The first part is always an 8 byte <a href="http://en.wikipedia.org/wiki/SipHash">SipHash</a> digest of all of the second part, using the first 16 bytes of the peer&#39;s hashname as the key input to the digest (identical to the <a class="xref" href="#channels_chat">chat channel</a>).  The variable bytes remaining in the fragment must be generated by the peer such that they are unique for every URI it shares.</p>
<p>The connecting party may not have a complete fragment, it only requires the first check digest before the <code>.</code> separator.  When the URI is resolved the peer must always respond with the full fragment in URI handshake and the connecting party must verify that the hashname is the correct key to generate the digest in the fragment of the complete second part.  This ensures that only that peer can correctly link from a specific URI and that the router cannot redirect to another party.</p>
<p>Example URI that uses a router as the base and includes the peer fragment (where <code>X</code>, <code>Y</code>, and <code>Z</code> are base32 values):</p>
<pre><code>link://127.0.0.1/?sid=42&amp;cs1a=X#Y.Z
</code></pre><p>When a URI is processed that contains a fragment it generates a new <a class="xref" href="#channels_peer">peer</a> request to the router that includes the <code>&quot;uri&quot;:&quot;...&quot;</code> (without the fragment) for the router to validate and resolve to the right peer.  The peer request must still also include a full URI handshake to be forwarded directly to the peer for its own validation.</p>
<h2>Processing:</h2>
<p>When processing a new URI, the steps are:</p>
<ol>
<li>detect included keys in the query string and derive hashname<ul>
<li>[optional] fallback to discover keys via WebFinger</li>
<li>fallback to resolve the canonical hostname to discover keys via DNS SRV</li>
<li>fallback to discover keys via OpenID Connect Discovery</li>
</ul>
</li>
<li>generate paths for all supported transports with any resolved IP and port</li>
<li>create a link with the keys and path(s) including a URI handshake</li>
<li>if there&#39;s a fragment hashname, issue a <code>peer</code> request over the link to it including a URI handshake<ul>
<li>process any response URI handshake with a validating fragment as the final resolution</li>
</ul>
</li>
</ol>
<h2>Embedded Keys</h2>
<p>The <code>CSKs</code> for an endpoint may be included in the query string of any existing URI.</p>
<p>Each <code>CSK</code> is included as an individual key/value pair where the key is the <code>CSID</code> in the format <code>cs??</code> (<code>cs1a</code>, <code>cs2a</code>, etc) and the value is always the base32 encoded key bytes.</p>
<h2>Embedded Paths</h2>
<p>The current paths may also be included in the query string of any existing URI.  Each available path has its JSON object base32 encoded as the value and is included with a common <code>paths</code> key, multiple paths have the same key.</p>
<p>When the paths match the ones generated from the hostname in the URI it is not necessary to include them in the query string.</p>
<p>Example paths:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">[</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"url"</code><code class="plain">: </code><code class="string">"<a href="http://192.168.0.36:42424">http://192.168.0.36:42424</a>"</code><code class="plain">,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"http"</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">},</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"192.168.0.36"</code><code class="plain">,</code></div><div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number9 index8 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"udp4"</code></div><div class="line number10 index9 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">},</code></div><div class="line number11 index10 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number12 index11 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"fe80::bae8:56ff:fe43:3de4"</code><code class="plain">,</code></div><div class="line number13 index12 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number14 index13 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"tcp6"</code></div><div class="line number15 index14 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></div><div class="line number16 index15 alt1"><code class="plain">]</code></div><div class="line number17 index16 alt2"><code class="plain">URL: proto:</code><code class="comments">//host/path?</code></div><div class="line number18 index17 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">key=value</code></div><div class="line number19 index18 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">&paths=pmrh...yce7i</code></div><div class="line number20 index19 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">&paths=pmrg...qrh2</code></div><div class="line number21 index20 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">&paths=pmrg...rcpu</code></div></div></td></tr></tbody></table></div><h2>Generated Paths</h2>
<p>The <code>canonical</code> hostname (or IP and port) of a URI or the resolved SRV <code>port</code> and <code>IP</code> should be treated as a potential <code>path</code> for all available transports for an endpoint.  Handshakes should be sent to the given address in every transport supported that can use an IP and port, including UDP, TCP, TLS, and HTTP(S).</p>
<h2>Link Discovery</h2>
<p>When an endpoint&#39;s keys cannot be included directly in the URI they may be discovered via automated techniques from other parts of the URI.</p>
<h3>DNS Links</h3>
<p>SRV records always resolve to a hashname-prefixed host, with TXT records returning all of the keys.</p>
<ul>
<li><code>_link._udp.example.com. 86400 IN SRV 0 5 42424 uvab...hv7g.example.com.</code></li>
<li><code>uvab...hv7g IN A 1.2.3.4</code></li>
<li><code>uvab...hv7g IN TXT &quot;1a=base32&quot;</code></li>
<li><code>uvab...hv7g IN TXT &quot;2a=base32&quot;</code></li>
<li><code>uvab...hv7g IN TXT &quot;2a2=base32&quot;</code></li>
<li><code>uvab...hv7g IN TXT &quot;3a=base32&quot;</code></li>
</ul>
<p>If a key&#39;s base32 encoding is larger than 250 characters (TXT limit), it is broken into multiple TXT records with the <code>CSID</code> being numerically increased so that it can be consistently reassembled.</p>
<p>No other DNS record type is supported, only SRV records resulting in one or more A and TXT records.</p>
<h3>WebFinger Links</h3>
<p>Use <a href="https://tools.ietf.org/html/rfc7033">WebFinger</a> against the canonical hostname, passing the given URI in as the <code>resource</code> and a <code>rel</code> value of <code>http://telehash.org/link</code>.  If successful, it will result in a valid <code>href</code> that must return the standard <a class="xref" href="#json">JSON link</a> description format.</p>
<pre><code>GET https://example.com/.well-known/webfinger?
  resource=http://example.com/~user1
  &amp;ref=http://telehash.org/link
{
  &quot;subject&quot;: &quot;http://example.com/~user1&quot;,
  &quot;links&quot; : [
    {
      &quot;rel&quot; : &quot;http://telehash.org/link&quot;,
      &quot;href&quot; : &quot;https://www.example.com/~user1/link.json&quot;
    }
  ]
}

GET https://example.com/~user1/link.json
{
  &quot;keys&quot;:{...},
  &quot;paths&quot;:[...]
}
</code></pre><p><a name="discovery" /></p>
<h2>OpenID Connect Discovery</h2>
<p>One or more hashnames may be advertised as part of <a href="http://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect Discovery</a> by simply including their <a class="xref" href="#jwk">JWK</a> in the <code>jwks_uri</code> response.  If there are multiple keys in the response only the first one in the array should be used to resolve the URI.</p>
<p>The discovery endpoint may also be used as a default authority to validate against for incoming unknown hashnames before responding to them.</p>
<p><a name="handshake" /></p>
<h2>URI Handshake</h2>
<p>When a URI is the source of a new link, a <code>&quot;type&quot;:&quot;uri&quot;</code> <a class="xref" href="#uri">handshake</a> should be sent including the original URI.</p>
<p>Example:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">:</code><code class="string">"uri"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"uri"</code><code class="plain">:</code><code class="string">"<a href="https://example.com/link?ref=42#u8kb...">https://example.com/link?ref=42#u8kb...</a>"</code></div><div class="line number4 index3 alt1"><code class="plain">}</code></div></div></td></tr></tbody></table></div></section><a id='e3x_intro' name='e3x_intro'></a><a id='chapter-10-0' name='chapter-10-0'></a><section data-type='chapter'><h1 id="e3x_intro">E3X - End-to-End Encrypted eXchange</h1>
<p><code>E3X</code> is a flexible end-to-end encrypted wire protocol, a specification for applications to route interoperable packetized content over any transport while protecting the privacy of those communications from network monitoring.</p>
<p>It is designed to be used as a low-level software library that can be embedded in any app.  It exposes <em>all</em> trust decisions to app layer, zero information or metadata is revealed to any network or endpoint without explicit instructions from the app.</p>
<p>All of the cryptographic primitives used in E3X are defined as a <a class="xref" href="#e3x_cs_">Cipher Set</a>, allowing for applications to select for different resource or security requirements as needed.</p>
<p><code>E3X</code> defines asynchronous <a class="xref" href="#e3x_messages">messages</a> and synchronous <a class="xref" href="#e3x_channels">channels</a> managed using an <a class="xref" href="#e3x_exchange">exchange</a>. Each <a class="xref" href="#e3x_exchange">exchange</a> has mutual session state established through explicit <a class="xref" href="#e3x_handshake">handshakes</a>.</p>
<p>An <a class="xref" href="#e3x_exchange">exchange</a> is created by combining keys for the local endpoint (one or more, depending on what Cipher Sets it supports) and has another endpoint&#39;s public key(s), the <a class="xref" href="#e3x_exchange">exchange</a> can then be used to create encrypted <a class="xref" href="#e3x_messages">messages</a> and generate <a class="xref" href="#e3x_handshake">handshakes</a> in both directions.</p>
<p>Once the <a class="xref" href="#e3x_handshake">handshakes</a> have been received and verified, encrypted <a class="xref" href="#e3x_channels">channels</a> can stream reliable or unreliable data between the two connected endpoints.  All data is encoded as <a class="xref" href="#lob">packets</a> both before (application layer) and after encryption (wire transport layer).</p>
<h2>Comparisons</h2>
<p>These are similar low-level encrypted wire protocols:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Off-the-Record_Messaging">OTR</a>, (<a href="https://otr.cypherpunks.ca/Protocol-v3-4.0.0.html">spec</a>)</li>
<li><a href="http://curvecp.org">CurveCP</a></li>
<li><a href="http://en.wikipedia.org/wiki/QUIC">QUIC</a> (<a href="https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit">spec</a>)</li>
<li><a href="http://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol">SRTP</a> (<a href="http://tools.ietf.org/html/rfc3711">spec</a>)</li>
<li><a href="https://www.ethos-os.org/~solworth/minimalt-20131031.pdf">MinimaLT</a></li>
</ul>
<p>No existing protocols met the requirements for telehash to minimize all metadata revealed to any network while also supporting both the sync and async communication patterns.</p>
<a id='e3x_exchange' name='e3x_exchange'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_exchange">Exchange - Endpoint Encryption State</h2>
<p>An <code>exchange</code> is the name of the current encryption state to one remote endpoint, a pairing between the local endpoint&#39;s private key and the remote endpoint&#39;s public key.</p>
<p>When a new <code>exchange</code> is created it will generate a unique public <a class="xref" href="#e3x_token">ROUTING TOKEN</a> value for that current instance, any incoming encrypted channel packets with that matching value can then be delivered to the appropriate <code>exchange</code>.</p>
<p>The <code>exchange</code> is used to generate and process all <a class="xref" href="#e3x_messages">messages</a>, <a class="xref" href="#e3x_handshake">handshakes</a>, and <a class="xref" href="#e3x_channels">channels</a>.  It can only generate channel packets after it has processed at least one handshake from the remote endpoint to set up the required synchronous encryption state.</p>
<p>An <code>exchange</code> internally keeps track of the current/best <code>at</code> value for the handshakes, validates incoming channel IDs, and generates new outgoing channel IDs.</p>
</section><a id='e3x_messages' name='e3x_messages'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_messages">Messages - Asynchronous Content Transport</h2>
<p>Message packets are for encrypting small amounts of content to other entities without requiring a synchronized <a class="xref" href="#e3x_exchange">exchange</a>, such that the recipient can process them at any point in the future.  They are used primarily for creating ephemeral <a class="xref" href="#e3x_handshake">handshakes</a> to establish synchronous <a class="xref" href="#e3x_channels">channel</a> encryption with forward secrecy guarantees.</p>
<p>Content sent in a message has a lower level of privacy since there is no forward secrecy protection like channels provide, if the recipient is compromised any past messages sent to it can be decrypted.  Messages should only be used minimally for temporary or non-secret data, all private or sensitive content should be sent over channels.  Messages should also never be stored at rest, logged, or archived.</p>
<p>Messages define how to encrypt the packets but have no required internal structure (unlike channels).  There is a larger overhead for encrypted message packets as they must always include the ephemeral public key information used and often require additional computation as well.</p>
<p>An <a class="xref" href="#e3x_exchange">exchange</a> may be created on demand just to generate/process one or more messages and not used for channels, but since messages are asynchronous they do not require the exchanges to be in sync to operate.</p>
<p>The size of an encrypted message is determined by the application and context in which it is used, handshakes are usually small (&lt;1400 bytes to maximize transport compatibility) and any messages intended to be sent over a transport with a low MTU may need to use <a class="xref" href="#e3x_chunking">chunked encoding</a> as the BODY of multiple messages.</p>
<h3>Packet Encryption</h3>
<p>All message packets are encrypted using a cipher as determined by the <a class="xref" href="#e3x_cs_">Cipher Set</a> in use for the exchange.  The encrypted (OUTER) packets must have a <code>HEAD</code> of length 1 to identify the CSID and the encrypted contents as the binary <code>BODY</code>.</p>
<p>Once decrypted they result in an INNER packet with a structure that is determined entirely by the application.  It is common practice for applications to use a <code>&quot;type&quot;:&quot;value&quot;</code> on the INNER JSON similarly to channel packets, but not required.  All INNER packets should contain a mechanism for the recipient to determine recency to ensure that the ephemeral keys already used can be invalidated and not-reused if required for forward secrecy.</p>
<h3>Stable Prefix</h3>
<p>All message packets generated from one exchange must have at least the first 16 bytes remain fixed for the lifetime of that exchange to be used for generating the <a class="xref" href="#e3x_token"><code>ROUTING TOKEN</code></a> and validation caching.</p>
</section><a id='e3x_order' name='e3x_order'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_order">Endpoint Order</h2>
<p>In order to prevent conflicts between any two endpoints, uniqueness is guaranteed by comparing the public keys of their agreed upon <a class="xref" href="#e3x_">cipher set</a>.</p>
<p>The binary value of each endpoint&#39;s public key is compared and they are placed in high-to-low sorted order.
To achieve this the two public keys can be visited bit by bit, the first key that at a given position has a <code>1</code> (<em>higher</em>) where the other has a <code>0</code> (<em>lower</em>) is the one that has <em>higher</em> order.</p>
<p>Based on this comparison the two are labeled as <code>ODD</code> (<em>high</em>) endpoint and an <code>EVEN</code> (<em>low</em>) endpoint.</p>
<p>This mechanism ensures that that both endpoints will mutually agree on their label consistently and without communication.</p>
</section><a id='e3x_handshake' name='e3x_handshake'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_handshake">Handshake - Mutual Exchange Creation</h2>
<p>A handshake is one or more encrypted <a class="xref" href="#e3x_messages">messages</a> sent between two endpoints in order to validate their identity and establish mutual <a class="xref" href="#e3x_exchange">exchange state</a> to use for <a class="xref" href="#e3x_channels">channels</a>.  At a minimum at least one handshake message must be both sent and received in order for the session to be created, with both endpoints verifying that it is always the most current one.</p>
<p>Applications may send or expect more than one handshake message for additional authentication and authorization requirements beyond the basic endpoint key exchange. New handshakes are also triggered automatically for existing sessions as needed by the transport(s) in use to verify that the network paths are still valid and/or maintain any NAT mappings.</p>
<p>The resulting size of encrypted handshake packets vary by which <a class="xref" href="#e3x_cs_">Cipher Sets</a> are used combined with the type of inner packet, typically it ranges from ~70 to ~1100 bytes.</p>
<h3>Resend/Timeout</h3>
<p>After a new handshake is generated and delivered it should be resent verbatim at <code>1</code> second, <code>3</code> seconds, <code>7</code> seconds, and again at <code>15</code> seconds unless there is a valid handshake response.  After <code>30</code> seconds with no response the exchange should be timed out, considered invalid and all related state removed.</p>
<p>At any point the transport being used to deliver packets may generate a keepalive handshake request which will start this process.</p>
<h3>Message Types</h3>
<p>Any decrypted handshake message is identified with a <code>&quot;type&quot;:&quot;...&quot;</code> string value, that if not included in the header must be defaulted to the type of <code>&quot;link&quot;</code>.  Only one unique type may exist concurrently (same <code>at</code> value) with any handshake process.</p>
<p>Known types include:</p>
<ul>
<li><strong><a class="xref" href="#e3x_link">link</a></strong> - to establish or keepalive a link</li>
<li><strong><a class="xref" href="#e3x_jwt">jwt</a></strong> - message <code>BODY</code> is a JSON Web Token encoded packet</li>
<li><strong><a class="xref" href="#e3x_uri">uri</a></strong> - a URI was used to generate this handshake and it is included as the <code>&quot;uri&quot;:&quot;...&quot;</code> value.</li>
<li><strong><a class="xref" href="#e3x_guides_bitcoin">tx</a></strong> - message <code>BODY</code> is a raw bitcoin transaction</li>
</ul>
<h3>Sequencing with <code>at</code></h3>
<p>All decrypted handshake messages must contain an <code>&quot;at&quot;:123456</code> with a 64 bit positive unsigned integer value to determine the newest generated handshake from either endpoint.  There is no requirement for the <code>at</code> value to be the current time, in sync, or accurate, only that it increases on all subsequent handshakes in the future from the last highest known value.</p>
<p>Multiple messages as part of one handshake must all have the same <code>at</code> value and different types, only one message per type with the highest <code>at</code> is used.</p>
<p>The <code>at</code> value determines if an incoming handshake is the most current and if the recipient needs to respond.  The last bit in the <code>at</code> must always match the <a class="xref" href="#e3x_order">order</a> value of the sender, if they are <code>ODD</code> it must be a 1 (and 0 if they are <code>EVEN</code>) to guarantee that no two endpoints can choose the same <code>at</code> independently.</p>
<p>When an <code>at</code> is received that is higher than one sent, new handshake message (or messages) must be returned with that matching highest <code>at</code> value in order to inform the sender that their handshake is confirmed.  Upon receiving and confirming a new <code>at</code>, any pending channel packets that may have been waiting to send may be flushed/delivered.</p>
<p>When first creating a handshake, the sender should make every effort to always choose a higher <code>at</code> than any they may have sent in the past.  Most can just use local <a href="http://en.wikipedia.org/wiki/Unix_time">32-bit epoch</a> as this value, but when not available (embedded systems) they should locally store the last sent <code>at</code> and always increase it.</p>
<p>If the maximum <code>at</code> value is ever reached/used the two hashnames cannot send any more subsequent handshakes and will no longer be able to communicate, either side must generate a new hashname to start over.</p>
<p><a name="token" /></p>
<h3>Routing Token</h3>
<p>The handshake determines the exchange&#39;s <code>ROUTING TOKEN</code> value, generated by SHA-256 hashing the first 16 bytes of the encrypted outer message <code>BODY</code>, then using the first 16 bytes of the digest output.  The <code>ROUTING TOKEN</code> is not used cryptographically and is only a unique value to assist the two endpoints and any routing parties on mapping to a known exchange session.</p>
<p>Each <a class="xref" href="#e3x_cs_">Cipher Set</a> must structure their messages such that the first 16 bytes of the <code>BODY</code> are unique and remain stable for the lifetime of the exchange, typically being the exchange&#39;s ephemeral public key bytes.</p>
<p>Any handshake with a different <code>ROUTING TOKEN</code> and a higher <code>at</code> of an existing exchange for the same endpoint must clear any cached handshake messages or state stored for that exchange.</p>
<h3>Handling Multiple Messages</h3>
<p>Immediately upon receiving a valid higher or equal <code>at</code> for any handshake message type, that message should be cached and replace any previous matching type with a <em>lower</em> <code>at</code> only (messages with matching <code>at</code> and <code>type</code> values must be discarded).  The message should also then be grouped with any other received messages with the same <code>at</code> and delivered to the application to process and validate.</p>
<p>If an application requires multiple message types it simply waits until the sufficient types arrive and process/validate them.  Application-invalidated handshakes must never be responded to so that the endpoint does not advertise its existence except to explicitly trusted/validated endpoints.</p>
<p>At any point the application may provide updated handshake message types to be sent in a new handshake process.  When the transport requests an updated handshake, the last known/provided message types are updated with a new <code>at</code> and re-sent.</p>
</section><a id='e3x_channels' name='e3x_channels'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_channels">Channels - Streaming Content Transport</h2>
<p>All streaming data sent between two endpoints in an exchange must be part of a <code>channel</code> packet. Every channel has an integer id included as the <code>c</code> parameter in the JSON and managed by the current <a class="xref" href="#e3x_exchange">exchange</a>. See <a class="xref" href="#e3x_ids">Channel IDs</a> for details on how they are selected/handled.</p>
<p>A channel may consist of only one outgoing initial packet, only one response to it, or it may be long-lived with many packets exchanged using the same &quot;c&quot; identifier (depending on the type of channel).  Channels are by default unreliable with no retransmit or ordering guarantees, and may optionally be created as <a class="xref" href="#e3x_reliable">reliable</a> that does provide ordering and retransmission functionality.</p>
<p>An <code>&quot;end&quot;:true</code> always signals the last <em>content</em> packet being sent for any channel type, for reliable channels there may be subsequent acks/retransmits after the end.</p>
<h3>Packet Size Default</h3>
<p>Channel packets should always be a maximum of 1400 bytes or less each, which allows enough space for added variable encryption, token, and transport overhead to fit within 1500 bytes total (one ethernet frame).  Larger data blocks should use reliable channels for sequencing and reassembly, and transports with a fixed lower MTU than 1400 should use <a class="xref" href="#e3x_chunking">chunked encoding</a> by default.</p>
<p>A channel library should provide a <code>quota</code> method per packet for the app to determine how many bytes are available within the 1400 limit, and app-specific channel logic can use this to break larger data into packets.  In special cases (such as with a local high bandwidth transport) when the transport MTU is known, the app or custom channel logic may ignore this and send larger/smaller packets.</p>
<h3>Packet Encryption</h3>
<p>All channel packets are encrypted using a stream cipher as determined by the <a class="xref" href="#e3x_cs_">Cipher Set</a> in use for the <a class="xref" href="#e3x_exchange">exchange</a>.  The encrypted (OUTER) packets must have a <code>HEAD</code> of length 0 and the encrypted contents as the binary <code>BODY</code>.</p>
<p>Once decrypted they result in an INNER packet that must always contain valid JSON (have a <code>HEAD</code> of 7 or greater).</p>
<h3>Decrypted Packets</h3>
<p>Base parameters on channel packets:</p>
<ul>
<li><code>&quot;type&quot;:&quot;value&quot;</code> - A channel always opens with a <code>type</code> in the first outgoing packet to distinguish to the recipient what the name/category of the channel it is. This value must only be set on the first packet (called the <em>open packet</em>), not on any subsequent ones or any responses.</li>
<li><code>&quot;end&quot;:true</code> - Upon sending any content packet with an <code>end</code> of true, the sender must not send any more content packets (reliability acks/resends may still be happening though). An <code>end</code> may be sent by either side and is required to be sent by <em>both</em> to cleanly close a channel, otherwise the channel will eventually close with a timeout.</li>
<li><code>&quot;err&quot;:&quot;message&quot;</code> - As soon as any packet on a channel is received with an <code>err</code> it is immediately closed and no more packets can be sent or received at all, any/all buffered content in either direction must be dropped. Any <code>err</code> packets must contain no channel content other than additional error details. Any internal channel inactivity timeout is the same as receiving an <code>&quot;err&quot;:&quot;timeout&quot;</code>.</li>
<li><code>&quot;seq&quot;:1</code> - A positive integer sequence number that is only used for and defined by <a class="xref" href="#e3x_reliable">reliable</a> channels and must be sent in the first open packet along with the <code>type</code>, it is an error to send/receive this without using reliability on both sides.</li>
</ul>
<p>An example unreliable channel start packet JSON for a built-in channel:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">:1,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">:</code><code class="string">"path"</code><code class="plain">,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"paths"</code><code class="plain">:[...]</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p>An example initial reliable channel open request:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">:2,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"seq"</code><code class="plain">:1,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">:</code><code class="string">"hello"</code><code class="plain">,</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"hello"</code><code class="plain">:{</code><code class="string">"custom"</code><code class="plain">:</code><code class="string">"values"</code><code class="plain">}</code></div><div class="line number6 index5 alt1"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p><a name="states" /></p>
<h4>Channel States</h4>
<p>A channel may only be in one of the following states:</p>
<ul>
<li><code>OPENING</code> - the initial channel open packet containing the <code>type</code> has been sent or received, but not confirmed or responded to yet and will time out in this state</li>
<li><code>OPEN</code> - the channel open packets have been both sent and received and it will not timeout unless the exchange does or reliability fails</li>
<li><code>ENDED</code> - a packet containing an <code>&quot;end&quot;:true</code> has been received and no further content will be delivered for this channel, it will be timed out</li>
</ul>
<p>These are the states that E3X manages, if an application requires additional states (such as when one party ended but the other hasn&#39;t) it must track them itself.  Any channel having received or sent an <code>err</code> is immediately removed after processing that packet and no more state is tracked, there is no channel error state.</p>
<p>Any channel in the <code>ENDED</code> state and has also sent an <code>end</code> is no longer available for any sending/receiving, but internal state will be tracked until the channel timeout for any necessary reliability retransmits/acknowledgements.</p>
<p><a name="ids" /></p>
<h4>Channel IDs</h4>
<p>A Channel ID is a <em>positive</em> integer (uint32_t) from 1 to 4,294,967,295 and is determined by the sender and then used by both sides to send/receive packets on that channel.  In order to prevent two endpoints from picking the same <code>c</code> value they choose them based on their <a class="xref" href="#e3x_order">order</a>: the <code>ODD</code> endpoint uses odd numbers starting with 1, and the <code>EVEN</code> endpoint uses even numbers starting with 2. 0 is never a valid ID.</p>
<p>When a new channel is created, the ID must be higher than the last one the initiator used, they must always increment. Upon receiving a new channel request, the recipient must validate that it is higher than the last active channel (note: switches must still allow for two new channel requests to arrive out of order).</p>
<p>When a new exchange is established, it errors any <code>OPEN</code> channels and sets the minimum required incoming channel IDs back to 1.</p>
<p>If the maximum ID is reached the exchange must be regenerated, resetting it back to 1.</p>
<p><a name="timeouts" /></p>
<h4>Timeouts</h4>
<p>Every channel is responsible for its own timeout and may have a different value than others.  A timeout occurs whenever the channel is in <code>OPENING</code> or <code>ENDED</code> state or when any packet has not been ack&#39;d for reliable channels.</p>
<p>Any channel that is in <code>OPEN</code> state will not trigger a timeout individually since the exchange as a whole will timeout if the connection is lost based on the network transports in use.  Those timeouts independently occur at a higher level for the overall exchange when the handshake process fails and do not use any channel timeout values.</p>
</section><a id='e3x_reliable' name='e3x_reliable'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_reliable">Reliable Channels</h2>
<p>Channel packets are by default only as reliable as the underlying transport itself is, which often means they may be dropped or arrive out of order.  Most of the time applications want to transfer content in a durable way, so reliable channels replicate TCP features such as ordering, retransmission, and buffering/backpressure mechanisms. The primary method of any application interfacing with an E3X library is going to be through starting or receiving reliable channels.</p>
<p>Reliability is requested on a channel with the very first packet (that contains the <code>type</code>) by including a <code>&quot;seq&quot;:1</code> with it, and a recipient must respond with an <code>err</code> if it cannot handle reliable channels.  Reliability must not be requested for channel types that are expected to be unreliable.</p>
<p><a name="seq" /></p>
<h3><code>seq</code> - Sequenced Data</h3>
<p>The requirement for a reliable channel is always including a simple incrementing <code>&quot;seq&quot;:1</code> positive integer value on every packet that contains any content (including the <code>end</code>). All <code>seq</code> values start at 1 with the open and increment per packet sent when it contains any data to be processed, with a maximum value of 4,294,967,295 (a 32-bit unsigned integer)</p>
<p>A buffer of these packets must be kept keyed by the seq value until the recipient has responded confirming them in an <a class="xref" href="#e3x_ack"><code>ack</code></a>. When the buffer is nearing full or new packets are being dropped, a <a class="xref" href="#e3x_miss"><code>miss</code></a> should be sent to indicate what is missing and the capacity left.</p>
<p>The receiving app logic must only process sequenced packets and their contents in order, any packets received with a sequence value that is older than already processed ones must be dropped, and any of order must either be buffered or dropped depending on local resources available.  </p>
<p><a name="ack" /></p>
<h3><code>ack</code> - Acknowledgements</h3>
<p>The <code>&quot;ack&quot;:1</code> integer is included on outgoing packets as the highest known <code>seq</code> value confirmed as <em>delivered to the app</em> (as much as is possible to confirm immediately). What this means is that any library must provide a way to send data/packets to the app using it in a serialized way, and be told when the app is done processing one packet so that it can both confirm that <code>seq</code> as well as give the app the next one in order. Any outgoing <code>ack</code> must be the last processed <code>seq</code> so that the sender can confirm that the data was completely received/handled by the recipient.</p>
<p>If a received packet contains a <code>seq</code> but does not contain an <code>ack</code> then the recipient is not required to send one for the given <code>seq</code> while it&#39;s still processing packets for up to one second.  This allows senders to manage their outgoing buffer of packets and the rate of ack&#39;s being returned, and ensures that an <code>ack</code> will still be sent at a regular rate based on what is actually received.</p>
<p>An <code>ack</code> may also be sent in its own packet ad-hoc at any point without any content data, and these ad-hoc acks must not include a <code>seq</code> value as they are not part of the content stream and are out-of-band.</p>
<p>When receiving an <code>ack</code> the recipient may then discard any buffered packets up to and including that matching <code>seq</code> id, and also confirm to the app that the included content data was received and processed by the other side.</p>
<p><a name="miss" /></p>
<h3><code>miss</code> - Missing Sequences</h3>
<p>The <code>&quot;miss&quot;:[1,2,4]</code> is an array of positive delta integers and must be sent along with any <code>ack</code> if in the process of receiving packets there are missing sequences. The array entries each represent a <code>seq</code> value calculated as the delta from the previous entry, using the accompanying <code>ack</code> as the initial base to start calculating from.</p>
<p>The last entry in the array always represents the <code>seq</code> id that the recipient will start dropping packets at, it is the maximum capacity of the incoming unprocessed packet buffer.  Whenever the buffer is over 50% full the recipient should send a <code>miss</code> to indicate the capacity left even if there are no other missing packets.  When the sender gets a <code>miss</code> it should always cache the total delta number as the maximum window size and never send packets with a higher <code>seq</code> than the last received <code>ack</code>+delta.</p>
<p>Upon receiving a <code>miss</code> the recipient should resend those specific matching calculated <code>seq</code> id packets in it&#39;s buffer. If the missing <code>seq</code> is signaled in multiple incoming packets quickly (happens often), the matching packet should only be resent once until at least one second has passed.</p>
<p>The <code>miss</code> recipient can make no assumptions about the sender&#39;s state of any <code>seq</code> ids higher than the <code>ack</code> and not included in the array, it can only use the values included as a signal that those sequences are missing.</p>
<h4><code>miss</code> delta encoding example</h4>
<p>Given the raw list of missing <code>seq</code> ids <code>[78236, 78235, 78245, 78238]</code> and <code>&quot;ack&quot;: 78231</code>.</p>
<ol>
<li>Sort the original list of missing seq ids:<br/>
<code>[78235, 78236, 78238, 78245]</code></li>
<li>Calculate the difference between all subsequent ids (including the <code>ack</code>).<br/>
<code>[(78235 - 78231), (78236 - 78235), (78238 - 78236), (78245 - 78238)]</code><br/>
<code>[4, 1, 2, 7]</code></li>
<li>If the incoming max buffer size is 20 packets, append the highest acceptable seq (<code>78251</code>) as a final delta (<code>78251 - 78245</code>).<br/>
<code>[4, 1, 2, 7, 6]</code></li>
<li>Deliver the final delta encoded <code>miss</code> array.</li>
</ol>
</section><a id='e3x_compression' name='e3x_compression'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_compression">Channel Payload Compression</h2>
<p>Since channel packets are the most frequent and have a set of fixed well-known key/values in their JSON headers, both endpoints may support optional channel compression encoding to minimize the resources required.</p>
<p>This is important in embedded/device networks where the MTU is small (BLE and 6lowpan), and may improve performance in other edge cases with frequent small packets.</p>
<h3><code>z</code> Link Handshake Signalling</h3>
<p>To indicate support of a channel payload compression any endpoint may include a <code>z</code> key with an unsigned integer value in the link handshake.  The value <code>0</code> is the default and signals no support.</p>
<p>The <code>z</code> value indicates how to decode/interpret the channel payload bytes immediately after decryption.  After any alternative processing the resulting value must still always be identical to a LOB packet with a JSON header and binary BODY, it is only to minimize encoding and not for use to include additional data in a payload.</p>
<p>Both endpoints must include identical <code>z</code> in a confirmed link handshake in order for it to be enabled on any channel packets using the resulting keys, and only that type of channel payload is supported when enabled. There is no negotiation or signalling of support for multiple values, future <code>z</code> values will be defined that combine multiple techniques when necessary.</p>
<h3><code>0</code> LOB encoded (default)</h3>
<p>All channel payload bytes are <a class="xref" href="#e3x_lob">LOB encoded</a>.</p>
<h3><code>1</code> CBOR encoded</h3>
<p>The value <code>1</code> signals support of <a href="http://cbor.io">CBOR based</a> payloads, the bytes are interpreted as a stream of CBOR values instead of LOB encoding.</p>
<ul>
<li>first value is always channel id (&quot;c&quot;, unsigned int)</li>
<li>[optional] byte string of a payload LOB packet</li>
<li>[optional] map of additional key/value pairs</li>
<li>[optional] text value is the &quot;type&quot; string value</li>
<li>[optional] unsigned int is a &quot;seq&quot; value</li>
<li>[optional] array is the &quot;ack&quot; and &quot;miss&quot; unsigned int values, ack is always the first value in the CBOR array</li>
</ul>
<h4>Decoding</h4>
<p>When processing CBOR the result is always a regular LOB packet with a JSON header.</p>
<ol>
<li>decode the channel id</li>
<li>if a byte string follows it is processed as the source LOB, if not then generate a blank/empty LOB packet</li>
<li>set the <code>&quot;c&quot;:id</code> in the packet JSON to the channel id from 1.</li>
<li>if a map follows, it&#39;s key/value pairs must be processed and only text keys and text or number values are used, each one being set in the packet JSON</li>
<li>if a text value follows, it is set as the <code>&quot;type&quot;:value</code> in the JSON</li>
<li>if an unsigned int follows, it is set as the <code>&quot;seq&quot;:value</code> in the JSON</li>
<li>if an array follows, it must be processed and only unsigned int values are used, the first one is always set as the <code>&quot;ack&quot;:value</code> and all other entries in the array are the <code>&quot;miss&quot;:[1,2,3]</code> in the JSON.</li>
</ol>
<h4>Examples</h4>
<p>JSON <code>{&quot;c&quot;:1,&quot;type&quot;:&quot;open&quot;}</code> (21) <a href="http://cbor.me/?diag=[1,%22open%22]">CBOR</a> (6):</p>
<pre><code>01          # unsigned(1) // c
64          # text(4)     // type
   6f70656e # &quot;open&quot;
</code></pre><p>JSON <code>{&quot;c&quot;:2,&quot;seq&quot;:22,&quot;ack&quot;:20,&quot;miss&quot;:[1,2,20]}</code> (41) <a href="http://cbor.me/?diag=[2,22,[20,1,2,20]]">CBOR</a> (7):</p>
<pre><code>02    # unsigned(2)  // c
16    # unsigned(22) // seq
84    # array(4)
   14 # unsigned(20) // ack
   01 # unsigned(1)
   02 # unsigned(2)
   14 # unsigned(20)
</code></pre><h3><code>2</code> DEFLATE encoded</h3>
<p>All channel payload bytes are encoded/decoded with <a href="http://tools.ietf.org/html/rfc1951">DEFLATE</a> before/after encryption.  The uncompressed bytes are always a normal LOB packet.</p>
</section><a id='e3x_cloaking' name='e3x_cloaking'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_cloaking">Cloaking - Network Obfuscation</h2>
<p>In situations where the network may be performing any packet filtering or inspection it is important to add as much random noise as possible to all bytes sent across an untrusted/unencrypted transport. Cloaking is a simple and efficient technique that can be used on any transport and is the default for all unencrypted ones by default (such as TCP and UDP).</p>
<p>The cloaking technique simply requires an extra processing step that adds a random number of 8 byte nonces to every packet and randomizes 100% of the bytes on the wire.  It makes large-scale pattern identification techniques significantly more difficult, but is not a guarantee that individual packets cannot be targetted.  Future designs will continually increase this difficulty.</p>
<h3>Per-Packet</h3>
<p>Due to all encrypted packets beginning with single zero byte (0x00) when sent on the wire (since they have no JSON encoded), cloaking uses a first byte that is any non-zero value (0x01 to 0xff).</p>
<p>Cloaking is performed using the <a href="http://cr.yp.to/chacha.html">ChaCha20 cipher</a> and choosing a random nonce of 8 bytes that does not begin with 0x00. The key is a fixed well-known 32 byte value of <code>d7f0e555546241b2a944ecd6d0de66856ac50b0baba76a6f5a4782956ca9459a</code> (shown as hex encoded), which is the SHA-256 of the string <code>telehash</code>.</p>
<p>The resulting cloaked packet is the concatenation of the 8-byte nonce and the ChaCha20 ciphertext output.  Once decloaked, the ciphertext should be processed as another packet, which may be a raw encrypted packet (0x00) or may be another cloaked one. A random number of multiple cloakings should always be used to obfuscate the original packet&#39;s size.</p>
<h3>Noise Floor</h3>
<p>Any endpoint may wish to obfuscate not only the individual packets but also the rate or timing of any transmission.  A noise floor can be established by generating random but valid cloaked packets of a minimum size and sending them continuously at a fixed rate to the recipient.  When real packets are waiting to be sent they are swapped out and sent instead of the next larger noise floor packet and cloaked multiple times to match the noise floor size.</p>
<h3>Accept both</h3>
<p>All implementations must support receiving both cloaked and uncloaked packets, and the default for any un-encrypted transport should always be cloaking enabled.  The initial sender determines when to send un-cloaked packets on any transport, but when receiving a cloaked packet any sender should always respond with cloaked packets as that may be the only way to ensure they are transmitted.</p>
</section><a id='e3x_cs_' name='e3x_cs_'></a><a id='section-10-1' name='section-10-1'></a><section data-type='section'><h2 id="e3x_cs_">Cipher Sets</h2>
<p>A Cipher Set (<code>CS</code>) is a group of crypto algrithms that are used to implement the core security functions as required by E3X.  Multiple sets exist to allow an evolution of supporting newer techniques as well as adapting to different system and deployment requirements.</p>
<p>A set always contains an endpoint public key cipher, an ephemeral public key cipher (for forward secrecy), and an authenticated streaming cipher.  Often a set uses the same public key algorithm for both the endpoint and epehemeral ciphers with different keys for each.</p>
<p><a name="csk" /></p>
<h3>Cipher Set Key (CSK)</h3>
<p>Each set can generate a single public key byte array called the Cipher Set Key (<code>CSK</code>) that is shared to other entities in order to generate outgoing or validate incoming messages.</p>
<p>The <code>CSK</code> is a consistent opaque value intended for use only by a given <code>CS</code>.  It must be tread as an arbitrary <em>binary octet string</em> when transferred, imported, or exported.</p>
<p><a name="csid" /></p>
<h3>Cipher Set ID (CSID)</h3>
<p>Each <code>CSK</code> is identified with a unique identifier (<code>CSID</code>) that represents its overall selection priority. The <code>CSID</code> is a single byte, typically represented in lower case hex. The <code>CSIDs</code> are always sorted from lowest to highest preference.</p>
<p>Two endpoints must always create <a class="xref" href="#e3x_exchange">exchanges</a> to each other using the highest common <code>CSID</code> between them.  Apps may choose which one or more <code>CSIDs</code> they want to support when they create an endpoint and know that a lower one will only ever be used to communicate with other endpoints that only support that <code>CS</code>.</p>
<p>Every <code>CS</code> requires a strong/secure random number generator in order to minimally function, some of them may have additional entropy requirements during <code>CSK</code> generation.</p>
<p>The <code>0x00</code> <code>CSID</code> is not allowed and always considered invalid.</p>
<p>Any <code>CSID</code> of <code>0x0*</code> (<code>0x01</code> through <code>0x0f</code>) is for experimental use when developing custom Cipher Sets and should not be used in production.</p>
<p><a name="reserved" /></p>
<h4>Reserved</h4>
<p>All <code>CSIDs</code> with the mask of <code>11111000</code> (<code>0x18</code> through <code>0x1f</code>, <code>0x28</code> through <code>0x2f</code>, etc) are reserved and their usage is specified in this table:</p>
<table>
<thead>
<tr>
<th>CSID</th>
<th>Status</th>
<th>Crypto</th>
<th>Uses</th>
</tr>
</thead>
<tbody>
<tr>
<td><a class="xref" href="#e3x_cs_1a">CS1a</a></td>
<td>Active</td>
<td>ECC-160, AES-128</td>
<td>Embedded, Browser</td>
</tr>
<tr>
<td><a href="https://github.com/telehash/telehash.org/blob/master/v3/e3x/cs/1b.md">CS1b</a></td>
<td>Draft</td>
<td>ECC-256, AES-128</td>
<td>Hardware-Accelerated</td>
</tr>
<tr>
<td><a href="https://github.com/telehash/telehash.org/blob/master/v3/e3x/cs/1c.md">CS1c</a></td>
<td>Draft</td>
<td>ECC-256k, AES-256</td>
<td>Bitcoin-based Apps</td>
</tr>
<tr>
<td><a class="xref" href="#e3x_cs_2a">CS2a</a></td>
<td>Active</td>
<td>RSA-2048, ECC-256, AES-256</td>
<td>Server, Apps</td>
</tr>
<tr>
<td><a href="https://github.com/telehash/telehash.org/blob/master/v3/e3x/cs/2b.md">CS2b</a></td>
<td>Draft</td>
<td>RSA-4096, ECC-521, AES-256</td>
<td>High-Security</td>
</tr>
<tr>
<td><a class="xref" href="#e3x_cs_3a">CS3a</a></td>
<td>Active</td>
<td>Curve25519, XSalsa20, Poly1305</td>
<td>Server, Apps</td>
</tr>
</tbody>
</table>
<p><a name="custom" /></p>
<h4>Custom</h4>
<p>Any <code>CSID</code> with the mask of <code>11110111</code> (<code>0x10</code> through <code>0x17</code>, <code>0x20</code> through <code>0x27</code>, etc) are for custom application usage, these Cipher Sets definitions are entirely app-specific.  Implementations are responsible for ensuring that the custom <code>CSIDs</code> match their security preferences.</p>
<p>See the <a href="https://github.com/telehash/telehash.org/blob/master/v3/e3x/cs/jose.md">JOSE-based</a> mapping draft for example custom <code>CSIDs</code>.</p>
<a id='e3x_cs_1a' name='e3x_cs_1a'></a><a id='section-10-2' name='section-10-2'></a><section data-type='section'><h3 id="e3x_cs_1a">Cipher Set 1a</h3>
<p>This is a minimum lightweight profile to support embedded devices and low resource environments.  It has additional constraints in place to minimize the code size and bytes on the wire (over speed) while maintaining a modern level of privacy.</p>
<p>The base algorithms used in this set are chosen to be readily implementable on embedded hardware (8bit 16mhz 32k AVR in &lt; 1 second) and are considered minimum-grade security:</p>
<ul>
<li><strong>ECC secp160r1</strong> - small key sizes, balance of relatively strong crypto and still supportable with low cpu</li>
<li><strong>HMAC-SHA256</strong> - common implementations available for embedded environments</li>
<li><strong>AES-128-CTR</strong> - low impact streaming cipher, many implementations including hardware ones</li>
</ul>
<h4>Keys</h4>
<p>When generating an endpoint including <code>CS1a</code>, the public/private keypair is an ECC <code>secp160r1</code> curve and the binary public key format is <a href="https://www.secg.org/collateral/sec1_final.pdf">compressed</a>, 21 bytes in length.</p>
<p>One key is generated permanently to identify the local endpoint, and one ephemeral key is generated on demand for every exchange created.</p>
<h4>Message BODY</h4>
<p>The BODY of any message packet is binary and defined with the following byte sections in sequential order:</p>
<ul>
<li><code>KEY</code> - 21 bytes, the sender&#39;s ephemeral exchange public key in compressed format</li>
<li><code>IV</code> - 4 bytes, a random but unique value determined by the sender</li>
<li><code>INNER</code> - the AES-128-CTR encrypted inner packet ciphertext</li>
<li><code>HMAC</code> - 4 bytes, the calculated HMAC of all of the previous KEY+IV+INNER bytes</li>
</ul>
<p>By performing ECDH with the received ephemeral key and the recipient&#39;s identity key, the resulting 20 byte secret is SHA-256 hashed and folded once to create the 16 byte AES-128 key along with the given IV (right-zero-padded to 16 bytes).</p>
<p>Another ECDH is performed with the sender and recipients identity key, and that 20 byte secret is combined with the given IV and input to HMAC-SHA256 of the entire BODY bytes (KEY+IV+INNER) minus the HMAC, then folded three times to get the 4 byte verification value that must match/be the last 4 bytes in the BODY.</p>
<h4>Channel Setup</h4>
<p>An exchange can generate or process channel packets once it has received a valid handshake.  The channel encryption is generated by using ECDH with the sent and received ephemeral keys from the handshakes, then performing a SHA-256 of the resulting 20 byte secret combined with the 21 byte compressed key values in each direction, and folding the 32 byte digests once to get the required 16 byte encryption and decryption key values for AES-128.</p>
<ul>
<li>channel encryption key: SHA256(secret, sent-KEY, received-KEY) / 2</li>
<li>channel decryption key: SHA256(secret, received-KEY, sent-KEY) / 2</li>
</ul>
<h4>Channel BODY</h4>
<p>CS1a channel packets are designed to be very lightweight with minimum overhead for use on networks such as 802.15.4 where there is a very low MTU.  The BODY is binary and defined as:</p>
<ul>
<li><code>TOKEN</code> - 16 bytes, from the handshake, required for all channel packets</li>
<li><code>IV</code> - 4 bytes, incremented sequence</li>
<li><code>INNER</code> - the AES-128-CTR encrypted inner packet ciphertext</li>
<li><code>HMAC</code> - 4 bytes, the SHA-256 HMAC folded three times</li>
</ul>
<p>The IV must be initialized to 4 random bytes during channel setup to make the individual channel packets less identifiable, and then incremented for every new channel packet created.</p>
<p>Using the correct channel 16 byte key with the given IV (right-zero-padded to the required 16 bytes), the channel packet can be encrypted/decrypted with AES-128-CTR.</p>
<p>The ciphertext then has a HMAC value calculated, with the input key being the same 16 byte key used for AES concatenated with the 4 byte IV to be a 20 byte secret key, and the body being the output of AES.</p>
<h4>Folding</h4>
<p>In order to minimize the over-the-wire footprint and match key sizes while using the same SHA-256 hashing algorithm that is required elsewhere, a 32-byte hash is folded once into a 16-byte value for usage as the fingerprint and as the input key for AES-128, and the 32-byte HMAC digest is folded three times into a smaller 4-byte value for usage as the MAC on message and channel packets.</p>
<p>The folding is a simple XOR of the lower half bytes with the upper ones, example pseudocode:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="keyword">var</code> <code class="plain">digest = sha256(</code><code class="string">"foo"</code><code class="plain">);</code></div><div class="line number2 index1 alt1"><code class="keyword">var</code> <code class="plain">folded = digest.slice(0,16);</code></div><div class="line number3 index2 alt2"><code class="keyword">for</code><code class="plain">(i = 0; i &lt; 16; i++) folded[i] = folded[i] ^ digest[i+16];</code></div></div></td></tr></tbody></table></div><p>The triple fold uses progressively smaller chunks of the input, as in this C code</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="keyword bold">void</code> <code class="plain">fold3(uint8_t in[32], uint8_t out[4])</code></div><div class="line number2 index1 alt1"><code class="plain">{</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">uint8_t i, buf[16];</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i=0;i&lt;16;i++) buf[i] = in[i] ^ in[i+16];</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i=0;i&lt;8;i++) buf[i] ^= buf[i+8];</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i=0;i&lt;4;i++) out[i] = buf[i] ^ buf[i+4];</code></div><div class="line number7 index6 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div></section><a id='e3x_cs_2a' name='e3x_cs_2a'></a><a id='section-10-2' name='section-10-2'></a><section data-type='section'><h3 id="e3x_cs_2a">Cipher Set 2a</h3>
<p>This profile is based on the algorithms used during the telehash v2 development process in 2013.</p>
<p>The required algorithms in this set are:</p>
<ul>
<li><strong>RSA 2048</strong> - selected as a well known and highly trusted public key algorithm and size, used as the long-lived identity</li>
<li><strong>ECC P-256</strong> - a well known curve with many implementations, used for the ephemeral identity</li>
<li><strong>AES 256-GCM</strong> - trusted common implementations available</li>
</ul>
<h4>Keys</h4>
<p>When generating an endpoint including <code>CS2a</code>, the public/private keypair is <a href="https://en.wikipedia.org/wiki/RSA_(algorithm">RSA 2048</a>).</p>
<p>Binary public keys are encoded in <a href="https://en.wikipedia.org/wiki/Distinguished_Encoding_Rules">DER</a> as X.509 SubjectPublicKeyInfo structures.  (Most cryptographic libraries support this encoding; see <a href="https://tools.ietf.org/html/rfc5280#section-4.1">RFC 5280 section 4.1</a> and <a href="https://tools.ietf.org/html/rfc3279#section-2.3.1">RFC 3279 section 2.3.1</a> for more details.) </p>
<p>The exchange ephemeral key is generated using <a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">ECC</a> and the <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf">p-256</a> curve, the resulting binary public key is <a href="https://www.secg.org/collateral/sec1_final.pdf">uncompressed</a> (65 bytes).</p>
<h4>Message BODY</h4>
<p>BODY bytes:</p>
<ul>
<li><code>KEYS</code> - 256 bytes, PKCS1 <a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding">OAEP</a> (v2) RSA encrpyted ciphertext of the 65 byte uncompressed ECC P-256 ephemeral public key and a 32 byte random AES key</li>
<li><code>IV</code> - 12 bytes, a random but unique value determined by the sender for each message</li>
<li><code>CIPHERTEXT</code> - <a href="http://en.wikipedia.org/wiki/Galois/Counter_Mode">AES-256-GCM</a> encrypted inner packet and sender signature</li>
<li><code>MAC</code> - 16 bytes, GCM 128-bit MAC/tag digest (some GCM implementations auto-append this)</li>
</ul>
<p>The <code>CIPHERTEXT</code> once deciphered contains:</p>
<ul>
<li><code>INNER</code> - inner packet raw bytes</li>
<li><code>SIG</code> - 256 bytes, PKCS1 v1.5 RSA signature of the KEYS+IV+INNER</li>
</ul>
<p>The <code>KEYS</code> is created by first generating a new ephemeral elliptic (ECC) public key for this exchange and a random 32 byte AES <code>KEY</code>, and then using the endpoint&#39;s RSA key to encrypt it <em>to</em> the recipient&#39;s RSA public key. The ECC keypair should be generated using the P-256 (<a href="http://tools.ietf.org/html/rfc6239#page-4">nistp256/secp256r/X9.62 prime256v1</a>) curve. The ECC public key should be in the uncompressed form 65 bytes in length (ANSI X9.63 format) followed by the 32 byte AES <code>KEY</code> bytes. The RSA encryption should use PKCS1 OAEP (v2) padding. The result is always padded to 256 bytes by OAEP.</p>
<p>The SIG is calculated from the concatenation of the <code>KEYS</code> (256 bytes of ciphertext), <code>IV</code> (12 bytes), and <code>INNER</code> (raw packet) together and then using the sender&#39;s RSA public key (SHA-256 hash and PKCS1 v1.5 padding) to create a signature of it, resulting in a 256 byte <code>SIG</code> value.</p>
<p>The <code>CIPHERTEXT</code> is created by encrypting the <code>INNER</code> and <code>SIG</code> (concatenated together) using AES-256-GCM.  The GCM IV/nonce parameter is the 12 byte (96-bit) <code>IV</code> value, and the key parameter is the 32 byte secret value following the ECC public key from the decrypted <code>KEYS</code>. The &quot;tag&quot; size for GCM is 16 bytes (128 bits), and the additional/auth data used to compute it is the 256 <code>KEYS</code> bytes, resulting in the <code>MAC</code> value appended to the original packet.</p>
<h4>Channel Setup</h4>
<p>The channel encryption/decryption secret keys are generated by using <a href="https://en.wikipedia.org/wiki/Elliptic_curve_DiffieâHellman">ECDH</a> with the local ephemeral ECC private key, and the remote ephemeral ECC public key. Two secret keys are generated by performing a SHA-256 with the derived ECDH derived secret (32 bytes) and sent/received decrypted secret keys from the <code>KEYS</code> value (32 bytes each):</p>
<ul>
<li>channel encryption key: SHA256(ecdh-secret, sent-KEY, received-KEY)</li>
<li>channel decryption key: SHA256(ecdh-secret, received-KEY, sent-KEY)</li>
</ul>
<h4>Channel BODY</h4>
<p>Channel packet binary <code>BODY</code> is defined as:</p>
<ul>
<li><code>TOKEN</code> - 16 bytes, from the handshake, required for all channel packets</li>
<li><code>IV</code> - 12 bytes, a random but unique value determined by the sender for each message</li>
<li><code>CHANNEL CIPHERTEXT</code> - the AES-256-GCM encrypted channel packet</li>
<li><code>GCM TAG/MAC</code> - (GMAC) - 16 bytes, GCM MAC digest (some GCM libraries auto-append this with the AES-256-GCM cipher output)</li>
</ul>
<p>The IV is 12 random bytes that must be different for every channel packet sent (incremented from a random seed) and used as the input to the GCM calculation, along with the appropriate encryption/decryption keys calculated for the exchange during setup.  The tag size for GCM is 12 bytes (96 bits) and no additiona/auth data is included as input to it.</p>
</section><a id='e3x_cs_3a' name='e3x_cs_3a'></a><a id='section-10-2' name='section-10-2'></a><section data-type='section'><h3 id="e3x_cs_3a">Cipher Set 3a</h3>
<p>Cipher Set 3a is based on Daniel J. Bernstein&#39;s <a href="http://nacl.cr.yp.to/index.html">NaCl: Networking and Cryptography library</a>.  The cipher set leverages the public-key and secret-key portions of NaCl.  Implementations will need to support the crypto_box, crypto_secretbox, and crypto_onetimeauth related functions.</p>
<p>The version of NaCl used for 3a is implemented with <code>crypto_box_curve25519xsalsa20poly1305</code>, future versions of NaCl with other configurations will be defined in different Cipher Sets.</p>
<h4>Keys</h4>
<p>All CS3a key pairs are generated using NaCl&#39;s <a href="http://nacl.cr.yp.to/box.html">crypto_box</a> from the components for public-key cryptography.</p>
<p>Here is some example code:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="keyword">var</code> <code class="plain">sodium = require(</code><code class="string">"sodium"</code><code class="plain">).api;</code></div><div class="line number2 index1 alt1"><code class="keyword">var</code> <code class="plain">keys = sodium.crypto_box_keypair();</code></div><div class="line number3 index2 alt2"><code class="plain">console.log(keys.publicKey); </code><code class="comments">// binary public key, 32 bytes</code></div></div></td></tr></tbody></table></div><h4>Message BODY</h4>
<p>The BODY of a message packet is binary and defined as the following byte sections in sequential order:</p>
<ul>
<li><code>KEY</code> - 32 bytes, the sending exchange&#39;s ephemeral public key</li>
<li><code>NONCE</code> - 24 bytes, randomly generated</li>
<li><code>CIPHERTEXT</code> - the inner packet bytes encrypted using secretbox() using the <code>NONCE</code> as the nonce and the shared secret (derived from the recipients endpoint key and the included ephemeral key) as the key</li>
<li><code>AUTH</code> - 16 bytes, the calculated onetimeauth(<code>KEY</code> + <code>NONCE</code> + <code>CIPHERTEXT</code>, SHA256(<code>NONCE</code> + secret)) using the shared secret derived from both endpoint keys, the hashing is to minimize the chance that the same key input is ever used twice</li>
</ul>
<h4>Channel Setup</h4>
<p>Channel secret keys are generated by performing a SHA-256 hash of the shared secret (agreedKey) and the <code>TOKEN</code> values:</p>
<ul>
<li>channel encryption key: SHA256(secret, sent-KEY, received-KEY) / 2</li>
<li>channel decryption key: SHA256(secret, received-KEY, sent-KEY) / 2</li>
</ul>
<h4>Channel BODY</h4>
<p>The enclosing channel packet binary is defined as the following byte sections in sequential order:</p>
<ul>
<li><code>TOKEN</code> - 16 bytes, from the handshake, required for all channel packets</li>
<li><code>NONCE</code> - 24 bytes, randomly generated</li>
<li><code>CIPHERTEXT</code> - the secretbox() output representing the encrypted inner packet</li>
</ul>
<p>See the <a href="https://github.com/telehash/telehash.org/blob/master/v3/guides/implementers.md#cs3a">implementers guide</a> for some example code.</p>
</section></section></section><a id='chunking' name='chunking'></a><a id='chapter-11-0' name='chapter-11-0'></a><section data-type='chapter'><h1 id="chunking">Packet Chunking</h1>
<p>Sending sequential <a class="xref" href="#lob">LOB</a> packet byte arrays over streaming transports (such as TCP/TLS) requires additional framing to indicate the size of each one. Framing is also necessary to break packets into smaller pieces for low MTU transports (such as Bluetooth LE and 802.15.4 based) and to signal flow control (Serial).</p>
<p>Chunking is a minimalist byte-encoding technique describing how to break any packet into multiple sequential chunks and re-assemble them into packets with low overhead. There is no CRC or other consistency checks as it is only designed to carry encrypted packets with their own internal validation and be implemented as a library utility for many transports with differing needs.</p>
<h2>Format</h2>
<p>A packet is broken into fragments of size 1 to 255 bytes each, and each fragment is prefixed with a single byte representing its length, together this is called a <code>chunk</code>. The sequence of one or more chunks is terminated with a zero-length terminator chunk, a single null byte.</p>
<p>Sequential chunks received that have any size should be appended to a buffer until the zero terminator chunk, at which point the buffer should be checked for a valid packet or discarded.  Any lone zero chunks with no buffer should be ignored.</p>
<p>Chunk size of 5:</p>
<pre><code>packet = [0,1,2,3,4,5,6,7,8,9]; // 10 byte packet
chunk1 = [4,0,1,2,3]; // 4-byte fragments
chunk2 = [4,4,5,6,7];
chunk3 = [2,8,9];
chunk4 = [0]; // terminator
</code></pre><p>When using chunks for fixed frame sizes the terminator should be included in the last frame if there&#39;s space, so the last frame for the example would be <code>[2,8,9,0]</code>.</p>
<h2>Acks</h2>
<p>At any point a zero-length chunk may be sent in response to a full incoming chunk and used by a transport for sending acknowedgement or keepalive signals.  Some transports may require this to manage flow control, buffer sizes, and detect timeouts faster.</p>
<p>This ack mechanism should not be used to try and create a reliable transport at this level, packets are expected to be safe to send unreliably and will internally be retransmitted when necessary.</p>
<h2>Transport Notes</h2>
<ul>
<li>TCP / TLS - default chunk size of 256, ensure a chunk or ack is written in response to processing one or more incoming chunks to help the sender detect timeouts faster</li>
<li>BLE - default chunk size of 20 to fit into a BLE data frame, no acks necessary</li>
<li>802.15.4 based transports - default chunk size of 120 bytes, no acks necessary (use 802.15.4 framing acks)</li>
<li>Serial - use the hardware serial buffer size (64 bytes for many arduino devices) as the chunk size, and require writing an ack for every chunk read for flow control to not overflow the hardware buffer</li>
</ul>
</section><a id='transports_' name='transports_'></a><a id='chapter-12-0' name='chapter-12-0'></a><section data-type='chapter'><h1 id="transports_">Transport Bindings</h1>
<p>Since telehash is designed to work over multiple network transports, there are bindings defined in this folder for how to send and receive the wire packets on different ones.</p>
<a id='transports_udp' name='transports_udp'></a><a id='section-12-1' name='section-12-1'></a><section data-type='section'><h2 id="transports_udp">UDP Transport</h2>
<p>Direct mapping, one packet to one message, always <a class="xref" href="#transports_e3x_cloaking">cloaked</a>.</p>
<p>Local port binding is dynamic (bind to <code>0</code>) unless given a specific port.  Implementations should support mapping the dynamic port via NAT-PMP and UPnP when possible.</p>
<p>Packets larger than the MTU may be fragmented by the router, but <a class="xref" href="#transports_chunking">chunking</a> should not be used for UDP messages, packets larger than a low MTU should be dropped so that higher level implementations can optimize the packet sizes and detect the MTU.</p>
<h3>Timeout</h3>
<p>A new keepalive handshake should be automatically triggered when no packets have been sent for 30 seconds in order to keep any NAT mappings active.</p>
<h3>Discovery</h3>
<p>UDP transports must always also listen on <code>*:42420</code> with broadcast enabled and also join the multicast address group <code>239.42.42.42</code> when available.</p>
<p>When discovery is enabled, the announcement packet(s) should be broadcast to the local LAN subnets port <code>42420</code> and the multicast group once every 10 seconds.</p>
<h3>Path JSON</h3>
<p>Example <a class="xref" href="#transports_channels_path">path</a> JSON for IPv4:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"192.168.0.55"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"udp4"</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p>Example <a class="xref" href="#transports_channels_path">path</a> JSON for IPv6:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"fe80::bae8:56ff:fe43:3de4"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"udp6"</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div></section><a id='transports_tcp' name='transports_tcp'></a><a id='section-12-1' name='section-12-1'></a><section data-type='section'><h2 id="transports_tcp">TCP Transport</h2>
<p>See <a class="xref" href="#transports_chunking">chunking</a> for how to encode one or more packets on a standard TCP socket.  All packets must be <a class="xref" href="#transports_e3x_cloaking">cloaked</a>.</p>
<p>Local port binding is dynamic (bind to <code>0</code>) unless given a specific port.  Implementations should support mapping the dynamic port via NAT-PMP and UPnP when possible.</p>
<h3>Multipath TCP</h3>
<p>Research is ongoing on how <a href="http://en.wikipedia.org/wiki/Multipath_TCP">Multipath TCP</a> can be used to optimize a normal TCP path.</p>
<h3>Timeout</h3>
<p>A new keepalive handshake may be automatically triggered when no packets have been sent for 5 minutes as an extra validation that the TCP socket is still connected.</p>
<h3>Discovery</h3>
<p>By default a TCP transport cannot support general discovery for local networks.</p>
<p>When given a specific IP and port to discover, the transport should ensure that the IP is on a local subnet and may then send the announcement packet(s) directly to that IP and port.  If the connection fails it may be retried once every 10 seconds, but if it succeeds and doesn&#39;t respond then no further announcements should be sent as long as it remains connected.</p>
<h3>Path JSON</h3>
<p>Example <a class="xref" href="#transports_channels_path">path</a> JSON for IPv4:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"192.168.0.55"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"tcp4"</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p>Example <a class="xref" href="#transports_channels_path">path</a> JSON for IPv6:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"fe80::bae8:56ff:fe43:3de4"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"tcp6"</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div></section><a id='transports_tls' name='transports_tls'></a><a id='section-12-1' name='section-12-1'></a><section data-type='section'><h2 id="transports_tls">TLS/SSL Transport</h2>
<p>Identical encoding to TCP (see <a class="xref" href="#transports_chunking">chunking</a>) and cloaking is only optional.</p>
<p>Applications may have additional requirements around the TLS identity/verification before using it as a transport.</p>
</section></section><a id='channels_' name='channels_'></a><a id='chapter-13-0' name='chapter-13-0'></a><section data-type='chapter'><h1 id="channels_">Channels</h1>
<p>Telehash defines a set of standard channels for implementations to support for interoperable built-in functionality.</p>
<p>The standard channels all use common simple names, so any application or library supporting a custom channel should use a <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-2">Collision-Resistant Name</a>: a name in a namespace that enables names to be allocated in a manner such that they are highly unlikely to collide with other names.</p>
<p>The current list of active and draft channels can always be found on <a href="https://github.com/telehash/telehash.org/tree/master/v3/channels">github</a>.</p>
<a id='channels_path' name='channels_path'></a><a id='section-13-1' name='section-13-1'></a><section data-type='section'><h2 id="channels_path"><code>path</code> - Network Path Information</h2>
<p>Any endpoint may have multiple network interfaces, such as on a mobile device both cellular and wifi may be available simutaneously or be transitioning between them, and for a local network there may be a public IP via the gateway/NAT and an internal LAN IP. Any endpoint should always try to discover and be aware of all of the network paths it has available to send on (ipv4 and ipv6 for instance), as well as all of the paths exist between it and any other endpoint. </p>
<p>An unreliable channel of <code>&quot;type&quot;:&quot;path&quot;</code> is the mechanism used to share and test any/all network paths available.  A path request may be generated automatically by any endpoint, based on either an initial link, a new incoming path, a change in local network information, or based on application signalling (a ping or connectivity validation request).</p>
<p>The initial request should contain an array of all of the paths the sender knows about itself, including local ones:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">: 1,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"path"</code><code class="plain">,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"paths"</code><code class="plain">: [</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"url"</code><code class="plain">: </code><code class="string">"<a href="http://192.168.0.36:42424">http://192.168.0.36:42424</a>"</code><code class="plain">,</code></div><div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"http"</code></div><div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">},</code></div><div class="line number9 index8 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number10 index9 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"192.168.0.36"</code><code class="plain">,</code></div><div class="line number11 index10 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number12 index11 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"udp4"</code></div><div class="line number13 index12 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">},</code></div><div class="line number14 index13 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{</code></div><div class="line number15 index14 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"fe80::bae8:56ff:fe43:3de4"</code><code class="plain">,</code></div><div class="line number16 index15 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number17 index16 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"tcp6"</code></div><div class="line number18 index17 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></div><div class="line number19 index18 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">],</code></div><div class="line number20 index19 alt1"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p>To handle a new <code>path</code> request, a response packet must be sent back to to every already known network path for the sender, as well as to any any new paths included in the request. The initiator should leave the channel open to receive any responses until the default timeout.  Every path response should include a <code>&quot;path&quot;:{...}</code> where the value is the specific path information the response is being sent to.</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">: 1,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"path"</code><code class="plain">: {</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"ip"</code><code class="plain">: </code><code class="string">"192.168.0.36"</code><code class="plain">,</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"port"</code><code class="plain">: 42424,</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">: </code><code class="string">"udp4"</code></div><div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></div><div class="line number8 index7 alt1"><code class="plain">}</code></div></div></td></tr></tbody></table></div><p><a name="paths" /></p>
<h3>Path Types</h3>
<p>The information about an available network transport is encoded as a JSON object that contains a <code>&quot;type&quot;:&quot;...&quot;</code> to identify which type of network it describes. The current path types defined are:</p>
<ul>
<li><code>udp4</code> / <code>udp6</code> - <a class="xref" href="#channels_transports_udp">UDP</a>, contains <code>ip</code> and <code>port</code>, may be multiple (public and private ip&#39;s)</li>
<li><code>tcp4</code> / <code>tcp6</code> - <a class="xref" href="#channels_transports_tcp">TCP</a>, contains <code>ip</code> and <code>port</code> like UDP</li>
<li><code>http</code> - contains <code>url</code> which can be http or https, see <a class="xref" href="#channels_transports_http">HTTP</a> for details</li>
<li><code>webrtc</code> - see <a class="xref" href="#channels_transports_webrtc">WebRTC</a>, ideal for browsers that have only HTTP support</li>
<li><code>peer</code> - contains <code>hn</code> which is sent <a class="xref" href="#channels_peer">peer</a> requests to provide routing assistance, optional <a class="xref" href="#channels_uri"><code>uri</code></a> if provided by the peer</li>
</ul>
</section><a id='channels_peer' name='channels_peer'></a><a id='section-13-1' name='section-13-1'></a><section data-type='section'><h2 id="channels_peer"><code>peer</code> - Routing Request</h2>
<p>Any endpoint can request another to act as a <a class="xref" href="#channels_routing">router</a> to an endpoint it is attempting to link with.  These routing requests are sent in a <code>&quot;type&quot;:&quot;peer&quot;</code> unreliable channel.  A peer request is typically generated as the result of having a <a class="xref" href="#channels_path">peer path</a> for any endpoint.</p>
<p>A peer open request contains a <code>&quot;peer&quot;:&quot;fvif...irkq&quot;</code> where the value is a the hashname the sender is trying to reach.  In some cases the hashname may not be known yet and the peer request was the result of a router-generated <a class="xref" href="#channels_uri">URI</a>, included as the <code>&quot;uri&quot;:&quot;...&quot;</code> value.</p>
<p>The <code>BODY</code> of the open request must contain an attached packet with information for the specified peer.  The <code>BODY</code> will be relayed by the routing endpoint to that peer who must validate the attached packet before processing or responding to it.  The validation requires application trust similarly to processing handshakes.</p>
<p>The recipient of the peer request is called the <a class="xref" href="#channels_routing">router</a> and must first qualify the specified <code>peer</code> value to make sure that it is able to establish a channel with it.  It must also ensure that either the sender or peer endpoints have an active link and are trusted to provide routing for.</p>
<p>Once validated, the <a class="xref" href="#channels_routing">router</a> relay&#39;s the original <code>BODY</code> in a <a class="xref" href="#channels_connect">connect</a> request to the peer.</p>
<p>No response is ever given to the <code>peer</code> channel, it should not error based on any validation so that the requesting endpoint cannot determine any information about the state of the peer.  The channel should always silently timeout and clean up.</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">:10,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">:</code><code class="string">"peer"</code><code class="plain">,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"peer"</code><code class="plain">:</code><code class="string">"fvif...irkq"</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div><div class="line number6 index5 alt1"><code class="plain">BODY: ...packet...</code></div></div></td></tr></tbody></table></div><h3>First Introductions</h3>
<p>The first time an endpoint is attempting a link with a new peer it may not have any information other than it&#39;s hashname, so it cannot send encrypted handshakes.  Instead, it must attach the handshakes unencrypted, with at least one of them including the sender&#39;s <code>CSK</code>.  If the sender doesn&#39;t know the correct <code>CSID</code> it should open multiple peer channels, one with each key handshake it supports.</p>
<h3>Automatic Bridging</h3>
<p>When the <code>BODY</code> contains an encrypted <a class="xref" href="#channels_e3x_handshake">handshake</a> packet the <a class="xref" href="#channels_routing">router</a> should determine the <a class="xref" href="#channels_token">ROUTING TOKEN</a> value of the handshake and create a mapping of that token to the network path that the peer request arrived via.  Any subsequent encrypted channel packets received with this token should be re-delivered to that network path, providing automatic bridging.</p>
<h3>URIs / Sessions</h3>
<p>If a peer is willing to be a <a class="xref" href="#channels_routing">router</a> for another peer to other unknown hashnames, it may generate a unique <a class="xref" href="#channels_uri">URI</a> including an opaque <code>session</code> value and send it as a <a class="xref" href="#channels_e3x_handshake">handshake</a> to that peer.  When the unknown hashname sends the <a class="xref" href="#channels_routing">router</a> a handshake it must include the URI in a handshake so that the router can validate the <code>session</code> and accept correct <code>peer</code> requests from them.  When the new hashname generates handshakes for the <code>peer</code> open it must aslso include a URI handshake again so that it can be re-verified by the destination peer.</p>
</section><a id='channels_connect' name='channels_connect'></a><a id='section-13-1' name='section-13-1'></a><section data-type='section'><h2 id="channels_connect"><code>connect</code> - Peer Connection Request</h2>
<p>A connect channel is only created from a <a class="xref" href="#channels_routing">router</a> that has received and validated a <a class="xref" href="#channels_peer">peer</a> request.  The original <code>BODY</code> of the peer open is attached as the <code>BODY</code> of the <code>&quot;type&quot;:&quot;connect&quot;</code> unreliable channel open packet. The original sender is included as <code>&quot;peer&quot;:&quot;uvab...hv7g&quot;</code> so that the recipient can track multiple handshakes from the same source.</p>
<p>The recipient should parse the attached <code>BODY</code> as a packet and process it as <a class="xref" href="#channels_e3x_handshake">handshake</a>, either encrypted or unencrypted (if the sender doesn&#39;t have the recipient&#39;s keys yet).  At least one of the handshakes should be a <a class="xref" href="#channels_csk">key</a> to guarantee the recipient can respond.  If any of them are invalid the requests should be ignored and the channel will timeout silently.</p>
<p>When accepted, a <a class="xref" href="#channels_path">peer path</a> should be implicitly added to the sender&#39;s hashname via the incoming <a class="xref" href="#channels_routing">router</a>.  When the processing of the attached packet results in a response handshake, it should then be delivered via a subsequent peer request via the same <a class="xref" href="#channels_routing">router</a>.</p>
<h3>Automatic Bridging</h3>
<p>When the incoming connect request has a <code>BODY</code> that is a validated handshake, the current network path it was received on should also be added as a network path to hashname of the handshake, since the <a class="xref" href="#channels_routing">router</a> provides automatic bridging for encrypted channel packets.</p>
</section><a id='channels_stream' name='channels_stream'></a><a id='section-13-1' name='section-13-1'></a><section data-type='section'><h2 id="channels_stream"><code>stream</code> - Reliable Data Streams</h2>
<p>One of the most common patterns between any two endpoints is creating streams of data.  The <code>&quot;type&quot;:&quot;stream&quot;</code> reliable channel is a request from one endpoint to open a stream to another.</p>
<p>The stream open request may contain a single additional packet attached as the <code>BODY</code> that is the options for this stream request, these options should contain anything the recipient app needs to determine what the stream is for and to create it.</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">:1,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">:</code><code class="string">"stream"</code></div><div class="line number4 index3 alt1"><code class="plain">}</code></div><div class="line number5 index4 alt2"><code class="plain">BODY: ...</code></div></div></td></tr></tbody></table></div><p>Once accepted (and once the open packet is acknowledged), the stream may immediately begin sending data in either direction.  All streamed data is attached as the binary <code>BODY</code> to every packet. The <code>JSON</code> may contain one of the following options:</p>
<ul>
<li><code>&quot;frag&quot;:true</code> - when set, the attached BODY should be buffered along with any other fragments in order, until a packet is received without a <code>frag</code> at which time they are all processed</li>
<li><code>&quot;enc&quot;:&quot;...&quot;</code> - what encoding is the attached data, current options are: <code>binary</code> (default), <code>json</code>, and <a class="xref" href="#channels_lob"><code>lob</code></a>.  This applies to any buffered fragments as well at the time it&#39;s processed (<code>enc</code> is not valid to be set when <code>frag</code> is true).</li>
</ul>
<p>Any channel <code>end</code> or <code>err</code> is processed normally and has the same implications for a stream.</p>
</section><a id='channels_sock' name='channels_sock'></a><a id='section-13-1' name='section-13-1'></a><section data-type='section'><h2 id="channels_sock"><code>sock</code> - Tunneled TCP/UDP Sockets</h2>
<p>A channel of <code>&quot;type&quot;:&quot;sock&quot;</code> is a request to create a minimal tunneled TCP or UDP socket, carrying arbitrary binary data.  It may be reliable for TCP, or unreliable to carry UDP.  It is designed to mirror the popular socket interfaces for the most common usage patterns, but not as an exhaustive or complete replacement.</p>
<p>The open packet must contain a <code>&quot;sock&quot;:value</code> where the value is one of <code>connect</code>, <code>bind</code>, or <code>accept</code>, and usually has a <code>&quot;src&quot;:{&quot;ip&quot;:&quot;1.2.3.4&quot;,&quot;port&quot;:5678}</code> and/or <code>dst</code> specified. An open may also contain the initial binary <code>BODY</code> payload to deliver if successful.</p>
<h3><code>connect</code></h3>
<p>Request to create a new socket to the given <code>dst</code>.  Any non-error packet response indicates the connection was opened. It may have an optional <code>&quot;src&quot;:{...}</code> indicating the known original source ip/port when proxying/tunneling.</p>
<h3><code>bind</code></h3>
<p>Request for the recipient to create a listening socket and bind to it.  If the <code>src</code> is included, only the <code>port</code> should be specified in it (and defaults to <code>0</code> if not) to indicate that the recipient chooses any open port to listen on.  The response must include a <code>dst</code> that specifies the current <code>ip</code> and <code>port</code> bound to this channel that the recipient may use/distribute.  The recipient should do whatever is necessary to ensure they are public usable addresses.</p>
<p>For an unreliable bind, sending and receiving UDP messages happens on the same channel using a <code>src</code> and <code>dst</code> address.  The sender specifies a <code>dst</code> to originate a new UDP message from the port, and receives incoming messages with a <code>src</code> indiciating where they came from.</p>
<p>For a reliable bind, incoming connections will individually open new <code>accept</code> channels from the recipient for each one.</p>
<h3><code>accept</code></h3>
<p>When the recipient has an active reliable <code>bind</code>, any new incoming connection will generate an accept channel and must have the <code>dst</code> of the originating bind along with the <code>src</code> address information.</p>
<p>An accept can also be generated for when a binding is created independently, if a hashname is listening on a TCP or UDP port on behalf of another without using a <code>bind</code> channel.  The semantics of <code>dst</code> and <code>src</code> are the same, and the accept channel may be reliable or unreliable.</p>
</section><a id='channels_thtp' name='channels_thtp'></a><a id='section-13-1' name='section-13-1'></a><section data-type='section'><h2 id="channels_thtp"><code>thtp</code> - HTTP Mapping</h2>
<p>This is a channel mapping HTTP to telehash for the common browser user-agent and web-app patterns.  Most HTTP requests can be translated directly into a <code>thtp</code> channel and back.</p>
<h3>Packet</h3>
<p>Any HTTP request/response is normalized into a packet by translating the headers into the JSON and any contents attached as the binary BODY.  The headers are always lower-cased keys and string values, for requests the <code>:method</code> (upper case) and <code>:path</code> with string values are included, and for responses the <code>:status</code> with the numeric value and optional <code>:reason</code> string value are included.</p>
<p>The request:</p>
<pre><code>GET / HTTP/1.1
User-Agent: curl/7.30.0
Accept: */*
</code></pre><p>Becomes:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">":method"</code><code class="plain">:</code><code class="string">"GET"</code><code class="plain">,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">":path"</code><code class="plain">:</code><code class="string">"/"</code><code class="plain">,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"user-agent"</code><code class="plain">:</code><code class="string">"curl/7.30.0"</code><code class="plain">,</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"accept"</code><code class="plain">:</code><code class="string">"*/*"</code><code class="plain">,</code></div><div class="line number6 index5 alt1"><code class="plain">}</code></div></div></td></tr></tbody></table></div><pre><code>BODY: empty
</code></pre><p>The response:</p>
<pre><code>HTTP/1.1 301 Moved Permanently
Server: nginx
Date: Fri, 07 Mar 2014 21:33:14 GMT
Content-Type: text/html
Content-Length: 178
Connection: keep-alive
Location: http://www.fooooo.com/

&lt;html&gt;
&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor=&quot;white&quot;&gt;
&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Becomes:</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">":status"</code><code class="plain">:301,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">":reason"</code><code class="plain">:</code><code class="string">"Moved Permanently"</code><code class="plain">,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"server"</code><code class="plain">:</code><code class="string">"nginx"</code><code class="plain">,</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"date"</code><code class="plain">:</code><code class="string">"Fri, 07 Mar 2014 21:12:39 GMT"</code><code class="plain">,</code></div><div class="line number6 index5 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"content-type"</code><code class="plain">:</code><code class="string">"text/html"</code><code class="plain">,</code></div><div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"content-length"</code><code class="plain">:</code><code class="string">"178"</code><code class="plain">,</code></div><div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"location"</code><code class="plain">:</code><code class="string">"<a href="http://www.fooooo.com/">http://www.fooooo.com/</a>"</code></div><div class="line number9 index8 alt2"><code class="plain">}</code></div></div></td></tr></tbody></table></div><pre><code>BODY:
&lt;html&gt;
&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor=&quot;white&quot;&gt;
&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3><code>thtp</code> channel</h3>
<p>A new request is initiated by creating a reliable channel of type <code>thtp</code>, multiples can be created simultaneously. These channels are always in one direction, the endpoint starting the channel can only send a request packet over it, and the receiving side can only send a response packet.  If the receiving needs to make requests, it can start a <code>thtp</code> channel in the other direction at any point.</p>
<p>The channel open packet includes all of or as much of the request packet as possible in the BODY, with subsequent packets if it needs to be fragmented and the last packet always including an <code>&quot;end&quot;:true</code> to end the channel.</p>
<p>The channel is also compatible with <a class="xref" href="#channels_stream">streams</a> such that an implementation can share the same underlying channel handler/streaming logic.</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">:1,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"seq"</code><code class="plain">:0,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"type"</code><code class="plain">:</code><code class="string">"thtp"</code><code class="plain">,</code></div><div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"end"</code><code class="plain">:</code><code class="keyword">true</code></div><div class="line number6 index5 alt1"><code class="plain">}</code></div><div class="line number7 index6 alt2"><code class="plain">BODY: request packet</code></div></div></td></tr></tbody></table></div><p>The response is the same pattern, with the BODY being a response packet, continuing in subsequent packets if necessary until the <code>&quot;end&quot;:true</code>.</p>
<div id="code" class="syntaxhighlighter  "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain">{</code></div><div class="line number2 index1 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"c"</code><code class="plain">:1,</code></div><div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"seq"</code><code class="plain">:1,</code></div><div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code><code class="string">"end"</code><code class="plain">:</code><code class="keyword">true</code></div><div class="line number5 index4 alt2"><code class="plain">}</code></div><div class="line number6 index5 alt1"><code class="plain">BODY: response packet</code></div></div></td></tr></tbody></table></div></section></section></body></html>
