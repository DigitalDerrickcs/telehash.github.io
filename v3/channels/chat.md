# `chat` - Direct and Group Private Messaging

This is a lightweight chat protocol designed to encourage minimal interoperable communication support in future telehash based apps and devices.  It is based the following principles:

* learn from the experiences with XMPP
* no central services or routing, is a full p2p mesh
* decoupled from identity
* real-time conversation focus, not optimized for archiving or ad-hoc async messaging
* rich media support
* multi-device aware
* for individuals and small/private groups, not for large/persistent groupchat

A `chat` is a container of one or more `messages` from one or more participants.  A participant is always a single [hashname](../hashname/), the list of participants for a single chat is called a `roster` and the first participant is called the `leader`.  Messages are typically sent synchronously over a `chat` channel, and may also be fetched on demand via [THTP](thtp.md) or sent asynchronously in a [box](box.md).

The simplest form of a `chat` between two `hashnames` is a single channel sending/receiving `messages` bi-directionally on that channel.

All chat and message IDs are 8 bytes generated using [SipHash](http://en.wikipedia.org/wiki/SipHash), then base32 encoded (identically to hashnames) when used in a string.

## Message IDs

Every message is identified by a unique ID that is generated by and specific to a single participant.  These message IDs are string encoded as a combination of a SipHash digest in base32, for example `cn33wzacvwfya`.

The first time any participant starts or accepts chat it must begin with a join message that is the result of a chain of digests.  The chain is created by using the first half of the participant's hashname (16 bytes) and starting with an initial random secret value (known only to the participant), then sequentially hashing the 8-byte digest outputs a large number of times (more than the potential number of messages to be sent in the chat). The final digest is the join message ID for the participant to use over the lifetime of the chat.

All messages must have sequentially previous digests as their ID so that the recipient can verify continuity and detect/derive missing message IDs.  A join ID cannot be changed, they are immutable once set, and any detected mismatch must error and close the chat.

The first participant is always the leader and their generated join ID also becomes the unique ID of the chat.

## Roster

Any hashname in the roster can either have the string value of "*" or their actual/known join message id, indicating that they are invited to join or already joined.

When new participants are added to the chat the nature of them connecting to everyone will trigger a roster update.  A cached roster can be used to determine the permission for any other incoming connection, any mismatch must trigger fetching the current one from the leader.  If it is a new chat then the roster and join messages can be fetched before deciding to join/accept and responding.

The joining participant should also try to initiate connections to the other participants via the leader (send a `peer` request directly to the leader for each participant), since they are connected already the leader can act as a temporary router to the other hashnames.

The chat interface style (UI) may be determined dynamically based on the roster and participants.  When there are only two participants (after resolving all the join messages and any `aka` values validated) it can be shown as a 1:1 interface to the user, otherwise it should be shown as a list of active/offline participants in a chatroom.

When fetched via THTP, the roster is a serialized JSON object:

```json
{
  "frnfke2szyna2vwkge6eubxtnkj46rtctqk7g7ewbvfiesycbjdq":"cbaccqcqiaqca",
  "e5mwmtsvueumlqgo32j67kbyjjtk46demhj7b6iibnnq36fsylka":"*",
  "w4qnrd3e4tnl2vsc337qzuo3fgwmbhaked5kb3myhgbgvrev6zfa":"*"
}
```

## THTP

The roster and individual messages can be fetched asynchronously using [THTP](thtp.md). The roster should only ever be requested from the leader, and individual messages should only be requested from each participant.  The leader must always be able to return the join messages for every participant as well.

* `thtp://2whzi65idcn33wzacvwfy2shsgdgtabr4gadcxtfbwhy2atxok2q/chat/sgoomt3lqqkia/roster`
  * **2whzi65idcn33wzacvwfy2shsgdgtabr4gadcxtfbwhy2atxok2q** the leader of the chat
  * **sgoomt3lqqkia** the base32 of the 8-byte chat id
  * **roster** request to return the raw JSON of the roster
* `thtp://kf7it53r5tvsylgsjzjrh4m7bsgb4jjygnr6nx3sgoomt3lqqkia/chat/sgoomt3lqqkia/id/4gadcxtfbwhy2`
  * **kf7it53r5tvsylgsjzjrh4m7bsgb4jjygnr6nx3sgoomt3lqqkia** the hashname of a participant in a chat
  * **sgoomt3lqqkia** the base32 of the 8-byte chat id
  * **id** request to return a message sent by this participant
  * **4gadcxtfbwhy2** the id of the message to return as a raw telehash packet

## Chat Channel

The chat channel is reliable and the start request/response looks like:

```json
{
  "c":1,
  "seq":1,
  "type":"chat",
  "chat":"sgoomt3lqqkia",
  "join":"4gadcxtfbwhy2",
  "last":"cn33wzacvwfya"
}
```

The fields are defined as:

* **type** - always `chat`
* **chat** - (only sent in the request) the id of the chat
* **join** - (required) the join id of the sender, must match if existing in roster
* **last** - (optional) the last chat message id from the sender, this can be used by the recipient to fetch any missed/historical ones from the sender

A chat channel can be opened by any hashname to another hashname that is either the leader or an existing participant, but it can only be initially started by the leader to invite a new hashname as a participant to an existing chat (participants can't invite each other directly).  An invitation from the leader always has a join value identical to the chat.

Once open, chat channels carry individual synchronous messages bi-directionally with each message having its own type value defined below.


###  Message Serialization

A message is a regular [LOB](../lob) encoded packet and can be of any size, so they must be broken into segments and re-assembled if they are larger than the capacity of a single chat channel packet.

To send a short message that fits in one packet it's just:

```json
{
  "c":1,
  "seq":1,
  "done":true
}
BODY: message packet
```

To break a 1841 byte message into parts it's:

```json
{
  "c":1,
  "seq":1
}
BODY: bytes 0 to 1000

{
  "c":1,
  "seq":2,
  "done":true
}
BODY: bytes 1001 to 1841
```


### `"type":"chat"` - Content Messages

Each chat message is a LOB-encoded packet who's JSON object has these common fields:

* **id** - (required) the unique message id as calculated by the sender
* **type** - (required) "chat"
* **text** - (required) plain text, optionally basic markdown
* **chat** - (optional) the chat id, must match the current context when sent via a channel/THTP
* **state** - (optional) senders current activity state [active, inactive, gone, composing, paused] based on [XEP-0085](http://xmpp.org/extensions/xep-0085.html)
* **after** - (required) the most recent message id in the chat the sender has seen
* **at** - (optional) epoch (in seconds, UTC)
* **refs** - (optional) object, key:uri pairs, references
* **alts** - (optional) object, key:string of alternate formats of the text content (rtf, xhtml, etc), if the value is a boolean `true` the alternate is attached as the BODY

```json
{
  "type":"chat",
  "id":"k46demhj7b6ii",
  "at":1394162554,
  "after":"qgo32j67kbyjj",
  "text":"...markdown \[ref\]\[\]...",
  "refs":{"ref":"uri:foo"}
}
```

The id must be validated with the sender's join. There may be images embedded in the markdown and should be loaded if possible.

Chat messages should only be updated as long as there were no other messages sent yet after it, subsequent identical chat message ids replace previous ones.  This can be displayed visually as either corrections/edited, or as-you-type live chat.

When a message text begins with "/me " the UI should display the message styled as an "action" coming from the sender.

### `"type":"join"` - Join Messages

A join message is required before any chat messages from any participant, its ID is always the highest digest of all message IDs.

* **id** - (required) the generated sequence digest id for the participant
* **type** - (required) "join"
* **text** - (required) plain text visible name
* **at** - (optional) epoch (in seconds, UTC)
* **after** - (optional) "last" value from chat invite, if given
* **refs** - (optional) object, key:uri pairs, references
* **aka** - (optional) array of other participant hashnames that are the same sending entity (to support multiple participating devices as one person)

```json
{
  "id":"cbaccqcqiaqca",
  "type":"join",
  "at":1394162554,
  "text":"Jeff Strongman",
  "refs":{"twitter":"http://twitter.com/strongman","email":"mailto:jeff@strongman.com","pic":"thtp:///profile/thumbnail.png","nick":"strongman"},
  "aka":["e5mwmtsvueumlqgo32j67kbyjjtk46demhj7b6iibnnq36fsylka"]
}
```

The join text is the name for display, with optional profile pic (may be a THTP url) and nickname in the refs.

The `aka` is other hashnames that must also be in the roster, and when validated by fetching their join message with a reciprocated hashname (or they're in "invited" state), messages from either should be visually displayed as from the same sender.  Joins with identical text/nick/pic (depending on what's displayed) and no matching `aka` should be modified visually so they are distinct (add a (2), etc).

The BODY may be a signed JWT that must contain the sender's `hashname` in the claims to be independently verified by the app.

### `"type":"ack"` - Receipt Messages

The chat channel can carry ad-hoc receipt messages alongside chats.  These messages have a `"type":"ack"` and are only sent from the recipient back to the sender/owner of a chat message.  They only signal a current state change and are never stored, cached, or re-sent.

```json
{
  "type":"ack",
  "id":"k46demhj7b6ii",
  "ack":"received"
}
```

Ack States:

* received - message was received and processed/queued/notified
* read - text was displayed
* seen - any embedded references were displayed (media)
* logged - chat was saved to external storage
* referred - a reference was followed (clicked/opened)
* saved - liked, bookmarked
* copied - clipboard, pic was copied, message was forwarded

Ack messages can be updated anytime, all of the states should replace/update the last received one.

