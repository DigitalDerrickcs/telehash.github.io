Cipher Set 3a
=============

Cipher Set 3a is based on Daniel J. Bernstein's [NaCl: Networking and Cryptography library](http://nacl.cr.yp.to/index.html).  The cipher set leverages the public-key and secret-key portions of NaCl.  Implementations will need to support the crypto_box, crypto_secretbox, and crypto_onetimeauth related functions.

The version of NaCl used for 3a is implemented with `crypto_box_curve25519xsalsa20poly1305`, future versions of NaCl with other configurations will likely be defined in different Cipher Sets.

## Keys

All CS3a key pairs are generated using NaCl's [crypto_box](http://nacl.cr.yp.to/box.html) from the components for public-key cryptography.

Here is some example code:
```js
var sodium = require("sodium").api;
var keys = sodium.crypto_box_keypair();
console.log(keys.publicKey); // binary public key, 32 bytes
```

## Message BODY

The BODY of a message packet is binary and defined as the following byte sections in sequential order:

* `KEY` - 32 bytes, the sending exchange's ephemeral public key
* `NONCE` - 24 bytes, randomly generated
* `CIPHERTEXT` - the inner packet bytes encrypted using secretbox() using the `NONCE` as the nonce and the shared secret (derived from the recipients endpoint key and the included ephemeral key) as the key
* `AUTH` - 16 bytes, the calculated onetimeauth(`KEY` + `CIPHERTEXT`, SHA256(`NONCE` + secret)) using the shared secret derived from both endpoint keys, the hashing is to minimize the chance that the same key input is ever used twice

## Channel Setup

Channel secret keys are generated by performing a SHA-256 hash of the shared secret (agreedKey) and the `TOKEN` values:

* line encryption key: SHA256(secret, sent-KEY, received-KEY)
* line decryption key: SHA256(secret, received-KEY, sent-KEY)

## Channel BODY

The enclosing channel packet binary is defined as the following byte sections in sequential order:

* `TOKEN` - 16 bytes, from the handshake, required for all channel packets
* `NONCE` - 24 bytes, randomly generated
* `CIPHERTEXT` - the secretbox() output representing the encrypted inner packet


## Example Code For Discussion (handshake)

The following example illustrates the usage of cs3a for the sending and receiving handshakes for a new exchange.  

> Warning: pseudo code interspersed with real code.

Sender (initiating a handshake):
```js
var sodium = require("sodium").api;

// Generate Switch Key Pair
// Upon switch initialization, an instance level key pair is generated for
// the switch.
var senderKeys = sodium.crypto_box_keypair();

// Generate Line Key Pair
// When the sender is ready to create an open request, a line specific key
// pair is generated.
var senderLineKeys = sodium.crypto_box_keypair();

// Sample SEQ value
var nonce = new Buffer(24);

// Generate the shared secret (agreedKey)
// Before any specific message handling, this "message independent pre-computaion"
// is performed, generating the agreedKey.  This shared secret is later used as a
// part of the encryption process for all packets sent over the line.
var agreedKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderLineKeys.secretKey);

// Sample inner packet
// (The json schema can be found in the spec for handshakes)
var plainText = JSON.stringify("This is a test chunk of data for the inner packet. it would have JSON and a payload of the sender publicKey");

// Encrypt the inner packet
// Note that this step uses NaCl's crypto_secretbox from the components for
// secret-key cryptography.
var innerPacketData = sodium.crypto_secretbox(new Buffer(plainText), nonce, agreedKey);

// Take the encrypted inner packet and the line level public key, and build the
// data section of the outer packet.
var openPacketData = Buffer.concat([senderLineKeys.publicKey, innerPacketData]);

// Generate the macKey
// The macKey uses the switch level private key.
var macKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderKeys.secretKey);
// add the nonce in with the macKey to make sure it's unique for onetimeauth
macKey = sodium.crypto_hash_sha256(Buffer.concat([nonce, macKey]));

// Generate the open MAC
// Note that this uses the NaCl's crypto_onetimeauth from the components for
// secret-key cryptography.
var openMAC = sodium.crypto_onetimeauth(openPacketData, macKey);

// Generate the outer packet BODY
// <SEQ><sender-public-key><encrypted-inner-packet-data><MAC>
var openPacketBody = Buffer.concat([nonce, openPacketData, openMAC]);

```


Receiver (accepting a handshake):
```js
var sodium = require("sodium").api;

// Generate Switch Key Pair
// Upon switch initialization, an instance level key pair is generated for
// the switch.
var receiverKeys = sodium.crypto_box_keypair();

// Generate Line Key Pair
// Upon receiving an open request, a line specific key pair is generated.
var receiverLineKeys = sodium.crypto_box_keypair();

// Unpack and authenticate the outer packet
//
// At this point, the open packet has been received.  Remember the following
// format:
// <SEQ><sender-line-public-key><encrypted-inner-packet-data><open-MAC>
//
var senderLineKeys.publicKey = ...  // the first 32 bytes
var nonce = ...                     // the next 24 bytes
var innerPacketData = ...           // the remaining bytes are the encrypted inner packet data
var openMAC = ...                   // the trailing 16 bytes 

// Generate the shared secret (agreedKey)
// This agreedKey will match the agreedKey generated by the sender, due to the
// corresponding public/private keys.  Here is the sender version for comparison:
//  agreedKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderLineKeys.secretKey);
//
var agreedKey = sodium.crypto_box_beforenm(senderLineKeys.publicKey, receiverKeys.secretKey);

// Decrypt the inner packet
// Using the agreedKey, the inner packet can now be decrypted. This should match
// the sample plaintext from the sender example.
var decryptedPacketData = sodium.crypto_secretbox_open(innerPacketData, nonce, agreedKey);

// Generate the macKey
// This macKey will match the macKey generated by the sender, due to the corresponding
// public/private keys.  Here is the sender version for comparison:
//  macKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderKeys.secretKey);
//
var macKey = sodium.crypto_box_beforenm(senderKeys.publicKey, receiverKeys.secretKey);

// add the nonce in with the macKey to make sure it's unique for onetimeauth
macKey = sodium.crypto_hash_sha256(Buffer.concat([nonce, macKey]));

var openPacketData = Buffer.concat([senderLineKeys.publicKey, decryptedPacketData]);

// Authenticate the open packet
// With all the pieces available, a onetimeauth verification can be completed.  If
// successful, this step completes the authentication of the open request.
var authed = sodium.crypto_onetimeauth_verify(openMAC, openPacketData, macKey) === 0 ;
console.log("Open mac verify:", authed);


```

