# URI Handling

This defines standard keys to embed in a URI that any endpoint can use to encode temporary or permanent connectivity information for sending in an out-of-band medium.

Once a URI is resolved to an endpoint, that information (keys and paths) should be stored and used in place of the URI, a successful resolution only needs to be performed once.

New URIs that are composed for the sole purpose of conveying hashname connectivity must always include a canonical hostname and optional port to use as the default path.

Processing:

1. detect included keys in the query string and validate hashname
2. can we resolve the canonical hostname to get keys via HTTP or DNS
3. create a link with the given path and keys, include a URI handshake
4. issue a `peer` request over the link including the `"uri":"..."`
5. process any response matching URI handshake as the final resolution

## Embedded Keys

The Cipher Set keys for an endpoint may be included in the query string or query-string encoded on the fragment of any existing URI.

Each `CSID` is included as an individual key/value pair where the key is the format `cs??` (`cs1a`, `cs2a`, etc) and the value is always the base32 encoded key bytes.

### DNS

SRV records always resolve to a hashname-prefixed host, with TXT records returning all of the keys.

* `_link._udp.example.com. 86400 IN SRV 0 5 42424 uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g.example.com.` (also optionally support `_tcp` and `_http`, etc)
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN A 1.2.3.4`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "1a=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a2=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "3a=base32"`

If a key's base32 encoding is larger than 250 characters, it is broken into multiple TXT records with the CSID being numerically increased so that it can be easily reassembled.

No other DNS record type is supported, only SRV records resulting in one or more A and TXT records.

### HTTP well-known

```
GET http://example.com/.well-known/mesh.json
{
  "keys":{...},
  "paths":{...}
}

## Transport Paths

With keys available, if the resolution of the canonical does not also result in `path` information and only an IP and Port are known, handshakes should be sent to that address in every transport supported that can use an IP and Port, including UDP, TCP, TLS, and HTTP(S).

## URI Handshake

When a URI is the source of a new link, a `"type":"uri"` [handshake](e3x/handshake.md#uri) should be sent including the original URI.  If a fragment was included it should be removed and not sent in the handshake.

## Peer/Connect Request

When a new [peer](channels/peer.md) request is made to a router resulting from the processing a URI, it should include the `"uri":"..."` without the fragment (if any).  If a subsequent [connect](channels/connect.md) is generated by the router the same `uri` value should be included in the connect request to the final endpoint to help it decide if it should respond.  When a fragment was included on the original URI that included the recipient keys, the sender is able to send an encrypted handshake over the peer channel.

The router may generate and share a custom `uri` in a [peer path](channels/path.md) so that it can facilitate the connection process, and should always include custom values in them to validate incoming handshake requests.  The endpoint using a router provided URI should attach a custom query string encoded value as the `#fragment` to identify it's own keys.

