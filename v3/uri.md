# URI Handling

URIs are a convenient method for endpoints to convey connectivity information in any out-of-band medium. This defines a process for handling any URI to detect keys and paths, as well as standard practices for embedding that information in any generated URIs.

Once a URI is successfully resolved and a link is established to an endpoint the key and path information should be stored and used in place of the URI, a successful resolution only needs to be performed once.


## Generation

New URIs that are generated by applications for the sole purpose of establishing a new link take the minimal form of: `protocol://canonical/?key=base32`

* `protocol://` - defaults to `link://` but may be any app-specific name for custom URL handlers
* `canonical` - typically takes the form of `IP:port` but may be any valid hostname
* `key=base32` - (optional) the sender's hashname keys

A generated URI will often include additional pathname or query string values as needed by the application.

Examples:

```
chat://127.0.0.1:55772/?1a=aof7baqdudm3mmjgexy5yqxj3m23pcsupy
```

### Router / Peer

A common architecture includes a designated router that facilitates the connection process with peers, and the router can generate an authorative URI for peers to use as a base when generating their own shareable URIs.

The router includes its own keys in the query string but does not attach a fragment, so that a peer can use the fragment part to include its keys and any additional data before distributing the URI.  The router should always include additional values in the base URI so that it can verify validity when processing incoming URI handshakes.

The router shares this base URI in a [peer path](channels/path.md) when supported.

## Processing:

1. detect included keys in the query string and derive hashname
2. can we resolve the canonical hostname to get keys via HTTP or DNS
3. create a link with the given path and keys, include a URI handshake
4. issue a `peer` request over the link including the `"uri":"..."`
5. process any response matching URI handshake as the final resolution
6. validate the hashname matches any included keys in the fragment and/or query

## Embedded Keys

The Cipher Set keys for an endpoint may be included in the query string or query-string encoded on the fragment of any existing URI.

Each `CSID` is included as an individual key/value pair where the key is the format `cs??` (`cs1a`, `cs2a`, etc) and the value is always the base32 encoded key bytes.

## Transport Paths

The `canonical` hostname (or IP and port) of a URI should be treated as a potential `path` for all available transports for an endpoint.  Handshakes should be sent to the given address in every transport supported that can use an IP and port, including UDP, TCP, TLS, and HTTP(S).

## Key Discovery

When an endpoint's keys cannot be included directly in the URI they may be discovered via automated techniques from other parts of the URI.

### DNS Keys

SRV records always resolve to a hashname-prefixed host, with TXT records returning all of the keys.

* `_link._udp.example.com. 86400 IN SRV 0 5 42424 uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g.example.com.` (also optionally support `_tcp` and `_http`, etc)
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN A 1.2.3.4`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "1a=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a2=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "3a=base32"`

If a key's base32 encoding is larger than 250 characters, it is broken into multiple TXT records with the CSID being numerically increased so that it can be easily reassembled.

No other DNS record type is supported, only SRV records resulting in one or more A and TXT records.

### HTTP `well-known` Keys

```
GET http://example.com/.well-known/link.json
{
  "keys":{...},
  "paths":{...}
}


## URI Handshake

When a URI is the source of a new link, a `"type":"uri"` [handshake](e3x/handshake.md#uri) should be sent including the original URI.  If a fragment was included it should be removed and not sent in the handshake.

## Peer/Connect Request

When a new [peer](channels/peer.md) request is made to a router resulting from the processing a URI, it should include the `"uri":"..."` without the fragment (if any).  If a subsequent [connect](channels/connect.md) is generated by the router the same `uri` value should be included in the connect request to the final endpoint to help it decide if it should respond.  When a fragment was included on the original URI that included the recipient keys, the sender is able to send an encrypted handshake over the peer channel.

The router may generate and share a custom `uri` in a [peer path](channels/path.md) so that it can facilitate the connection process, and should always include custom values in them to validate incoming handshake requests.  The endpoint using a router provided URI should attach a custom query string encoded value as the `#fragment` to identify it's own keys.

