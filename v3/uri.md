# URI Handling

URIs are a convenient method for endpoints to convey connectivity information in any out-of-band medium. This defines a process for handling any URI to automatically detect associated keys and paths, as well as standard practices for embedding that information in any generated URIs.

Once a URI is successfully resolved and a link is established to an endpoint the key and path information should be stored and used in place of the URI, a successful resolution only needs to be performed once.

## Generation

New URIs that are generated by applications for the sole purpose of establishing a new link take the minimal form of: `link://host:port/?csid=base32`

* `link://` - defaults to `link` but may be any app-specific name for registering custom URL handlers
* `host:port` - the `host` is often an IP address, and the port defaults to `42424` if not included
* `csid=base32` - (optional) a key/value pair for each of the sender's public keys

A generated URI will often include additional pathname or query string values as needed by the application.

Examples:

```
chat://127.0.0.1:55772/?1a=aof7baqdudm3mmjgexy5yqxj3m23pcsupy
```

### Router / Peer

A common architecture includes a designated router that facilitates the connection process with peers.  The router can generate an authorative base URI for peers to use when generating their own shareable URIs and advertises it to the peer in a [path](channels/path.md) request.

The router may include its own keys in the query string but may not attach a `#fragment` so that a peer can use the fragment part to include its identity and any additional data before distributing the URI.  The router should always include additional values in the base URI to validate incoming requests.

The peer endpoint must include its hashname in the fragment and should also attach additional query-string encoded values for it to validate incoming requests.

Example URI that uses a router as the base and includes the peer values in the fragment:

```
link://127.0.0.1/?sid=1zm3hv7g&cs1a=aof7baqdudm3mmjgexy5yqxj3m23pcsupy#invite=hqr3vf9c&hashname=jpnzr4n33kwqbgpw3mduf7takvczpx2gafzjc2ppfc4yrxkltzsa
```

When a URI is processed that contains a fragment with a hashname it generates a new [peer](channels/peer.md) request to the router.  The peer request must include the `"uri":"..."` for the router to re-validate before processing.  The request must still also include a full URI handshake to be forwarded directly to the peer.


## Processing:

1. detect included keys in the query string and derive hashname
  * [optional] fallback to discover keys via WebFinger
  * fallback to resolve the canonical hostname to discover keys via DNS SRV
  * fallback to discover keys via HTTPS well-known
2. generate paths for all supported transports with any resolved IP and port
3. create a link with the keys and path(s) including a URI handshake
4. if there's a fragment hashname, issue a `peer` request over the link to it including a URI handshake
  * process any response handshake matching the hashname as the final resolution

## Embedded Keys

The Cipher Set keys for an endpoint may be included in the query string of any existing URI.

Each `CSID` is included as an individual key/value pair where the key is the format `cs??` (`cs1a`, `cs2a`, etc) and the value is always the base32 encoded key bytes.

## Generated Paths

The `canonical` hostname (or IP and port) of a URI or the resolved SRV `port` and `IP` should be treated as a potential `path` for all available transports for an endpoint.  Handshakes should be sent to the given address in every transport supported that can use an IP and port, including UDP, TCP, TLS, and HTTP(S).

## Link Discovery

When an endpoint's keys cannot be included directly in the URI they may be discovered via automated techniques from other parts of the URI.

### DNS Links

SRV records always resolve to a hashname-prefixed host, with TXT records returning all of the keys.

* `_link._udp.example.com. 86400 IN SRV 0 5 42424 uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g.example.com.`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN A 1.2.3.4`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "1a=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "2a2=base32"`
* `uvabrvfqacyvgcu8kbrrmk9apjbvgvn2wjechqr3vf9c1zm3hv7g IN TXT "3a=base32"`

If a key's base32 encoding is larger than 250 characters (TXT limit), it is broken into multiple TXT records with the `CSID` being numerically increased so that it can be consistently reassembled.

No other DNS record type is supported, only SRV records resulting in one or more A and TXT records.

### WebFinger Links

Use [WebFinger](https://tools.ietf.org/html/rfc7033) against the canonical hostname, passing the given URI in as the `resource` and a `rel` value of `http://telehash.org/link`.  If successful, it will result in a valid `href` that must return the standard [JSON](json.md) link description format.

```
GET https://example.com/.well-known/webfinger?resource=http://example.com/~user1&ref=http://telehash.org/link
{
  "subject": "http://example.com/~user1",
  "links" : [
    {
      "rel" : "http://telehash.org/link",
      "href" : "https://www.example.com/~user1/link.json"
    }
  ]
}

GET https://example.com/~user1/link.json
{
  "keys":{...},
  "paths":[...]
}
```

### HTTPS `well-known` Links

Return the standard [JSON](json.md) link description format under the root `/.well-known/` path:

```
GET https://example.com/.well-known/link.json
{
  "keys":{...},
  "paths":[...]
}

## URI Handshake

When a URI is the source of a new link, a `"type":"uri"` [handshake](e3x/handshake.md#uri) should be sent including the original URI.

Example:

```json
{
  "type":"uri",
  "uri":"https://example.com/link?ref=42"
}
```
