Cipher Set 3a
============

Cipher Set 3a is based on Daniel J. Bernstein's [NaCl: Networking and Cryptography library](http://nacl.cr.yp.to/index.html).  The cipher set leverages the public-key and secret-key portions of NaCl.  Implementations will need to support crypto_box, crypto_secretbox, and crypto_onetimeauth related functions.


## Switch Key Pair and Fingerprint
When a switch is first initialized, it must generate a key pair and fingerprint for each cipher set.  For cs3a, this key pair is generated using NaCl's [crypto_box](http://nacl.cr.yp.to/box.html) from the components for public-key cryptography.

Here is some example code:
```js
var sodium = require("sodium").api;
var keys = sodium.crypto_box_keypair();
console.log(keys.publicKey); // binary public key, 32 bytes
console.log(crypto.createHash("sha256").update(keys.publicKey).digest("hex")); // fingerprint
```

## Open

In order to create a new line, a switch must generate a new, temporary key pair for that line.  This key pair is also created using crypto_box.  The public key for the line is called the `LINE KEY`.  After a successful open handshake, both parties will be in posession of a shared secret (agreedKey).

The BODY of the open packet is binary and defined as the following byte sections in sequential order:

* `AUTH` - 32 bytes, the calculated onetimeauth(line key, inner ciphertext)
* `LINE KEY` - 32 bytes, the sender's temporary line public key
* `INNER CIPHERTEXT` - the secretbox() encrypted inner packet

## Line

After a line has been opened, the line encryption keys are generated by performing a SHA-256 hash of the shared secret (agreedKey) and the line ids from each switch:

* line encryption key: SHA256(secret, my-line-id, their-line-id)
* line decryption key: SHA256(secret, their-line-id, my-line-id)

The enclosing line packet binary is defined as the following byte sections in sequential order:

* `NONCE` - 24 bytes, randomly generated
* `CHANNEL CIPHERTEXT` - the secretbox() output representing the encrypted inner packet


## Example Code For Discussion (open handshake)

The following example illustrates the usage of cs3a for the sending and receiving sides of an `open` request.

Sender (initiating an open request):
```js
var sodium = require("sodium").api;

// Generate Switch Key Pair
// Upon switch initialization, an instance level key pair is generated for
// the switch.
var senderKeys = sodium.crypto_box_keypair();

// Generate Line Key Pair
// When the sender is ready to create an open request, a line specific key
// pair is generated.
var senderLineKeys = sodium.crypto_box_keypair();

// Generate a 24 byte nonce of 0
var nonce = new Buffer(24);
for (var i = 0; i < 24; ++i) {
  nonce[i] = 0;
}

// Before any specific message handling, a message independent pre-computaion
// is performed, generating the agreedKey.  This key is used as a part of the
// encryption process for all packets sent over the line.
var agreedKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderLineKeys.secretKey);

// Sample inner packet (json fields can be found in spec for open)
var plainText = JSON.stringify("This is a test chunk of data for the inner packet. it would have JSON and a payload of the sender publicKey");

// Encrypt the inner packet
// Note that this step uses NaCl's crypto_secretbox from the components for secret-key cryptography
var innerPacketData = sodium.crypto_secretbox(new Buffer(plainText), nonce, agreedKey);

// Take the encrypted inner packet and build the data section of the outer packet
var openPacketData = Buffer.concat([senderLineKeys.publicKey, innerPacketData]);

// Generate the macKey using the switch level private key
var macKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderKeys.secretKey);

// Generate the HMAC
// Note that this uses the NaCl's crypto_onetimeauth from the components for
// secret-key cryptography
var openHMAC = sodium.crypto_onetimeauth(openPacketData, macKey);

// Sender can now send HMAC, public line key and the encrypted open packet data

```

Receiver (accepting an open request):
```js
var sodium = require("sodium").api;

// Generate Switch Key Pair
// Upon switch initialization, an instance level key pair is generated for
// the switch.
var receiverKeys = sodium.crypto_box_keypair();

// Generate Line Key Pair
// Upon receiving an open request, a line specific key pair is generated.
var receiverLineKeys = sodium.crypto_box_keypair();

// Generate a 24 byte nonce of 0 (same as sender for open)
var nonce = new Buffer(24);
for (var i = 0; i < 24; ++i) {
  nonce[i] = 0;
}

// Get the agreedKey out of the packet
// Note that it will match the agreedKey generated by the sender, due to the
// corresponding public/private keys.  Here is the sender version for
// comparison:
//  agreedKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderLineKeys.secretKey);
//
var agreedKey = sodium.crypto_box_beforenm(senderLineKeys.publicKey, receiverKeys.secretKey);

// Decrypt the inner packet
// This will match the sample plaintext from the sender example
var decryptedPacketData = sodium.crypto_secretbox_open(innerPacketData, nonce, recvAgreedKey);

// Generate the macKey
// Note that it will match the macKey generated by the sender, due to the
// corresponding public/private keys.  Here is the sender version for
// comparison:
//  macKey = sodium.crypto_box_beforenm(receiverKeys.publicKey, senderKeys.secretKey);
//
var macKey = sodium.crypto_box_beforenm(senderKeys.publicKey, receiverKeys.secretKey);

// Validate the HMAC of the outer packet
// Now the receiver also generates the same openHMAC with that macKey.  Then, having
// generated the openHMAC and macKey as the sender, the open packet can be validated
// by verifying the HMAC with crypto_onetimeauth_verify.
var openHMAC = sodium.crypto_onetimeauth(openPacketData, macKey);
var authed = sodium.crypto_onetimeauth_verify(openHMAC, openPacketData, macKey) === 0 ;
console.log("Open hmac verify:", authed);
```

